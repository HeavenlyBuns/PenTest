package kmp;


/**
 * 假设有一个主字符串,一个子字符串,如何才能知道 主字符串是否包含子字符串?
 * kmp搜索: O(M+N)的时间复杂度
 * 目的: 主串无需从头开始匹配
 */
public class KmpStr1 {

    public static void main(String[] args) {
        String p = "abcdabcg";
        buildNxtArr(p);

    }


    /**
     *  例如: a b c d a b c g
     *
     *  是否含有相同的前缀和后缀?
     *      a b c d a b c g
     *      |-- |
     *      并不含有相同的前缀和后缀,所以下一次匹配需要从0开始
     */

    /**
     * KMP算法核心在于 构建 Nxt数组,计算失配表,也就是字符模版匹配表
     * 要点:   int j = 0, i = 1; 下标 j  从0开始, 下标 i 从1开始
     * 当 arr[i] = arr[j], j = j + 1;
     * <p>
     * 1. 在匹配子串的时候,已经匹配过的则直接跳过
     * (例如: 子串为 "abab", 匹配串为: "ababc",匹配串在 匹配到 c的时候,子串则不从0开始,从 index = 2开始匹配,节省时间)
     * 2. 第n位匹配出错之后，说明前n－1位都是匹配相同的,寻找是否有相同的前缀和后缀,
     */
    public static void buildNxtArr(String pattern) {
        char[] paChat = pattern.toCharArray();
        int[] nxtArr = new int[paChat.length];
        // j 是 匹配成功就 + 1,同时也是匹配的下标
        int j = 0, idx = 0;
        for (int i = 1; i < paChat.length; ) {
            char ci = paChat[i];
            char cj = paChat[j];
            if (ci == cj) {
                j++;
                nxtArr[i] = j;
                i++;
            } else if (j != 0) {
                /**
                 *  是否有相同的前后缀判断,当 j != 0 的时候,代表已经有共同的前后缀,则从前缀的上一位再去匹配
                 *    当已经有匹配成功的字符,当前的字符却不匹配的时候,则将 上一次的匹配成功的值 重新赋给 j 后,
                 *              j 不仅是是匹配表成功的值,同时也是匹配成功的 下标索引值,例如  paChat[i] =  paChat[j]
                 *    j = 上一次匹配成功的值 - 1, 左移一位再去比较
                 */
                j = nxtArr[j - 1];
            } else {
                nxtArr[i] = 0;
                i++;
            }
        }
    }

}

# Hibernate常见面试题

## Hibernate工作原理及为什么要用？

> Hibernate工作原理及为什么要用？

1. 读取并解析配置文件
2. 读取并解析映射信息，创建SessionFactory
3. 打开Sesssion
4. 创建事务Transation
5. 持久化操作
6. 提交事务
7. 关闭Session
8. 关闭SesstionFactory



![img](https://user-gold-cdn.xitu.io/2018/3/9/1620a5ecda5b57e5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



使用Hibernate框架就不用我们写很多繁琐的SQL语句。**Hibernate实现了ORM，能够将对象映射成数据库表，从而简化我们的开发！**

## Hibernate是如何延迟加载(懒加载)?

> Hibernate是如何延迟加载(懒加载)?

通过设置属性`lazy`进行设置是否需要懒加载

当Hibernate在查询数据的时候，数据并没有存在与内存中，**当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载**，他节省了服务器的内存开销，从而提高了服务器的性能。

## Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)

> Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)

它们通过配置文件中的`many-to-one、one-to-many、many-to-many`来实现类之间的关联关系的。

## hibernate的三种状态之间如何转换

> hibernate的三种状态之间如何转换

Hibernate中对象的状态：

- **临时/瞬时状态**
- **持久化状态**
- **游离状态**

### 临时/瞬时状态

当我们**直接new出来的对象就是临时/瞬时状态的**..

- **该对象还没有被持久化【没有保存在数据库中】**
- **不受Session的管理**



![这里写图片描述](https://user-gold-cdn.xitu.io/2018/3/8/1620601774e5a7e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### 持久化状态

**当保存在数据库中的对象就是持久化状态了**

- **当调用session的save/saveOrUpdate/get/load/list等方法的时候，对象就是持久化状态**
- **在数据库有对应的数据**
- **受Session的管理**
- **当对对象属性进行更改的时候，会反映到数据库中!**



![这里写图片描述](https://user-gold-cdn.xitu.io/2018/3/8/16206017750e04bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



我们来测试一下：**当对对象属性进行更改的时候，会反映到数据库中!**

```
        session.save(idCard);
        idCard.setIdCardName("我是测试持久化对象");

复制代码
```



![这里写图片描述](https://user-gold-cdn.xitu.io/2018/3/8/1620601774f5774d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### 游离状态

**当Session关闭了以后，持久化的对象就变成了游离状态了...**

- **不处于session的管理**
- **数据库中有对应的记录**



![这里写图片描述](https://user-gold-cdn.xitu.io/2018/3/8/16206017ff19e7af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



有了上面的基础，我们就很容易说出它们之间的转换了

- **new出来的对象是瞬时状态->保存到数据库中(受Session管理)就是持久化状态->将session close掉就是游离状态**

## 比较hibernate的三种检索策略优缺点

> 比较hibernate的三种检索策略优缺点

**立即检索：**

- 优点： 对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象；
- 缺点： 1.select语句太多；2.可能会加载应用程序不需要访问的对象白白浪费许多内存空间；
- 立即检索:`lazy=false`；

**延迟检索：**

- 优点： 由应用程序决定需要加载哪些对象，可以避免可执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且能节省内存空间；
- 缺点： 应用程序如果希望访问游离状态代理类实例，必须保证他在持久化状态时已经被初始化；
- 延迟加载：`lazy=true`；

**迫切左外连接检索：**

- 优点： 1对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便地冲一个对象导航到与它关联的对象。2使用了外连接，select语句数目少；
- 缺点： 1 可能会加载应用程序不需要访问的对象，白白浪费许多内存空间；2复杂的数据库表连接也会影响检索性能；
- 预先抓取： `fetch=“join”`；

## hibernate都支持哪些缓存策略

> hibernate都支持哪些缓存策略

usage的属性有4种：

- 放入二级缓存的对象，只读(Read-only);
- 非严格的读写(Nonstrict read/write)
- 读写； 放入二级缓存的对象可以读、写(Read/write)；
- 基于事务的策略(Transactional)

## hibernate里面的sorted collection 和ordered collection有什么区别

> hibernate里面的sorted collection 和ordered collection有什么区别

sorted collection

- 是在**内存中通过Java比较器**进行排序的

ordered collection

- 是在**数据库中通过order by**进行排序的

对于比较大的数据集，**为了避免在内存中对它们进行排序而出现 Java中的OutOfMemoryError，最好使用ordered collection。**

## 说下Hibernate的缓存机制

> 说下Hibernate的缓存机制

**一级缓存：**

- Hibenate中一级缓存，也叫做session的缓存，**它可以在session范围内减少数据库的访问次数！  只在session范围有效！ Session关闭，一级缓存失效！**
- **只要是持久化对象状态的，都受Session管理，也就是说，都会在Session缓存中！**
- Session的缓存由hibernate维护，**用户不能操作缓存内容； 如果想操作缓存内容，必须通过hibernate提供的evit/clear方法操作**。

**二级缓存：**

- **二级缓存是基于应用程序的缓存，所有的Session都可以使用**
- Hibernate提供的二级缓存有默认的实现，且是一种**可插配的缓存框架**！如果用户想用二级缓存，**只需要在hibernate.cfg.xml中配置即可**； 不想用，直接移除，不影响代码。
- 如果用户觉得hibernate提供的框架框架不好用，**自己可以换其他的缓存框架或自己实现缓存框架都可以**。
- Hibernate二级缓存：**存储的是常用的类**



![这里写图片描述](https://user-gold-cdn.xitu.io/2018/3/8/16206017d6e37062?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



## Hibernate的查询方式有几种

> Hibernate的查询方式有几种

- 对象导航查询(objectcomposition)
- HQL查询
  - 1、 属性查询
  - 2、 参数查询、命名参数查询
  - 3、 关联查询
  - 4、 分页查询
  - 5、 统计函数
- Criteria 查询
- SQLQuery本地SQL查询

## 如何优化Hibernate？

> 如何优化Hibernate？

- Ø 数据库设计调整
- Ø HQL优化
- Ø API的正确使用(如根据不同的业务类型选用不同的集合及查询API)
- Ø 主配置参数(日志，查询缓存，fetch_size, batch_size等)
- Ø 映射文件优化(ID生成策略，二级缓存，延迟加载，关联优化)
- Ø 一级缓存的管理
- Ø 针对二级缓存，还有许多特有的策略

详情可参考资料：

- [www.cnblogs.com/xhj123/p/61…](https://www.cnblogs.com/xhj123/p/6106088.html)

## 谈谈Hibernate中inverse的作用

> 谈谈Hibernate中inverse的作用

**inverse属性默认是false**,就是说关系的两端都来维护关系。

- 比如Student和Teacher是多对多关系，用一个中间表TeacherStudent维护。Gp)
- 如果Student这边inverse=”true”, 那么关系由另一端Teacher维护，就是说当插入Student时，不会操作TeacherStudent表（中间表）。只有Teacher插入或删除时才会触发对中间表的操作。所以两边都inverse=”true”是不对的，会导致任何操作都不触发对中间表的影响；当两边都inverse=”false”或默认时，会导致在中间表中插入两次关系。

**如果表之间的关联关系是“一对多”的话，那么inverse只能在“一”的一方来配置！**

详情可参考：

- [zhongfucheng.bitcron.com/post/hibern…](https://zhongfucheng.bitcron.com/post/hibernate/hibernate-inversehe-cascadeshu-xing-zhi-shi-yao-dian)

## JDBC hibernate 和 ibatis 的区别

> JDBC hibernate 和 ibatis 的区别

### jdbc:手动

- 手动写sql
- delete、insert、update要将对象的值一个一个取出传到sql中,不能直接传入一个对象。
- select:返回的是一个resultset，要从ResultSet中一行一行、一个字段一个字段的取出，然后封装到一个对象中，不直接返回一个对象。

### ibatis的特点:半自动化

- sql要手动写
- delete、insert、update:直接传入一个对象
- select:直接返回一个对象

### hibernate:全自动

- 不写sql,自动封装
- delete、insert、update:直接传入一个对象
- select:直接返回一个对象

## 在数据库中条件查询速度很慢的时候,如何优化?

> 在数据库中条件查询速度很慢的时候,如何优化?

1. 建索引
2. 减少表之间的关联
3. 优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据量大的表排在前面
4. 简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据

详情可参考：

- https://mp.weixin.qq.com/s?timestamp=1520300404&src=3&ver=1&signature=W6Fo7aDHiJtK4ecUcnSJ4h9bN0vRAcTPKBTgLWSJDsMcdQReJC487RYzUIU9UFYQdmgLFyss9cKifM*GFp*CEVLtaLlwjj2HaDOjsCRkTnwfVlUY5cDhSyRi-c8leheofZJVnu6wYQ3IvT*hYyVB1pQCqqnuXIWERaksjXuyNP8=

## 什么是SessionFactory,她是线程安全么

> 什么是SessionFactory,她是线程安全么

**SessionFactory 是Hibrenate单例数据存储和线程安全的，以至于可以多线程同时访问**。一个SessionFactory 在启动的时候只能建立一次。SessionFactory应该包装各种单例以至于它能很简单的在一个应用代码中储存.

## get和load区别

> get和load区别

- **get()立即查询**



![这里写图片描述](https://user-gold-cdn.xitu.io/2018/3/9/1620824e66fb8a1a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- **load()懒加载**



![这里写图片描述](https://user-gold-cdn.xitu.io/2018/3/9/1620824e670f239c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- 1）get如果没有找到会返回null， load如果没有找到会抛出异常。
- 2）get会先查一级缓存， 再查二级缓存，然后查数据库；load会先查一级缓存，如果没有找到，就创建代理对象， 等需要的时候去查询二级缓存和数据库。

## merge的含义：

> merge的含义：

- 如果session中**存在相同持久化标识(identifier)的实例**，用用户给出的对象的状态**覆盖旧有的持久实例**
- 如果session**没有相应的持久实例**，则尝试从数据库中加载，或创建新的持久化实例,最后返回该持久实例
- **用户给出的这个对象没有被关联到session上，它依旧是脱管的**

详情可参考：

- [cp3.iteye.com/blog/786019](http://cp3.iteye.com/blog/786019)

## persist和save的区别

> persist和save的区别

- **persist不保证立即执行，可能要等到flush；**
- **persist不更新缓存；**
- save, 把一个瞬态的实例持久化标识符，及时的产生,它要返回标识符，所以它会**立即执行Sql insert**
- 使用 save() 方法保存持久化对象时，**该方法返回该持久化对象的标识属性值(即对应记录的主键值)；**
- 使用 persist() 方法来保存持久化对象时，**该方法没有任何返回值**。

参考资料：

- [blog.csdn.net/u010739551/…](http://blog.csdn.net/u010739551/article/details/47253881)

## 主键生成 策略有哪些

> 主键生成 策略有哪些

**主键的自动生成策略**

- identity  自增长(mysql,db2)
- sequence  自增长(序列)， oracle中自增长是以序列方法实现**
- native  自增长【会根据底层数据库自增长的方式选择identity或sequence】
  - **如果是mysql数据库, 采用的自增长方式是identity**
  - **如果是oracle数据库， 使用sequence序列的方式实现自增长**
- increment  自增长(会有并发访问的问题，一般在服务器集群环境使用会存在问题。)

指定主键生成策略为**手动指定主键的值**

- **assigned**

指定主键生成策略为**UUID生成的值**

- **uuid**

**foreign(外键的方式)**

## 简述hibernate中getCurrentSession和openSession区别

> 简述hibernate中getCurrentSession和openSession区别

- 1、getCurrentSession会绑定当前线程，而openSession不会，因为我们把hibernate交给我们的spring来管理之后，我们是有事务配置，这个有事务的线程就会绑定当前的工厂里面的每一个session，而openSession是创建一个新session。
- 2、**getCurrentSession事务是有spring来控制的**，而openSession需要我们手动开启和手动提交事务，
- 3、**getCurrentSession是不需要我们手动关闭的**，因为工厂会自己管理，而openSession需要我们手动关闭。
- 4、而**getCurrentSession需要我们手动设置绑定事务的机制**，有三种设置方式，jdbc本地的Thread、JTA、第三种是spring提供的事务管理机制org.springframework.orm.hibernate4.SpringSessionContext，而且srping默认使用该种事务管理机制

## Hibernate中的命名SQL查询指的是什么?

> Hibernate中的命名SQL查询指的是什么?

- 命名查询指的是用``标签在影射文档中定义的SQL查询，可以通过使用Session.getNamedQuery()方法对它进行调用。命名查询使你可以使用你所指定的一个名字拿到某个特定的查询。
- Hibernate中的命名查询可以使用注解来定义，也可以使用我前面提到的xml影射问句来定义。在Hibernate中，@NameQuery用来定义单个的命名查询，@NameQueries用来定义多个命名查询。

## 为什么在Hibernate的实体类中要提供一个无参数的构造器这一点非常重要？

> 为什么在Hibernate的实体类中要提供一个无参数的构造器这一点非常重要？

每个Hibernate实体类必须包含一个 无参数的构造器, 这是因为**Hibernate框架要使用Reflection API，通过调用Class.newInstance()来创建这些实体类的实例**。如果在实体类中找不到无参数的构造器，这个方法就会抛出一个InstantiationException异常。

## 可不可以将Hibernate的实体类定义为final类?

> 可不可以将Hibernate的实体类定义为final类?

你**可以**将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，**因为Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，** 如此一来就限制了使用可以提升性能的手段。



### **24. 为什么要使用 hibernate？**

- Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码
- Hibernate是一个基于jdbc的主流持久化框架，是一个优秀的orm实现，它很大程度的简化了dao层编码工作
- Hibernate使用java的反射机制，而不是字节码增强程序类实现透明性
- Hibernate的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系
- *Hibernate本身性能并不是很好，存在很多优化手段 （一级缓存、二级缓存、查询缓存、抓取策略）。

### **25. 什么是 ORM 框架？**

ORM（Object Relational Mapping）框架采用元数据来描述对象与关系映射的细节，元数据一般采用XML格式，并且存放在专门的对象一映射文件中。

只要提供了持久化类与表的映射关系，ORM框架在运行时就能参照映射文件的信息，把对象持久化到数据库中。当前ORM框架主要有五种：Hibernate(Nhibernate)，iBATIS，mybatis，EclipseLink，JFinal。

ORM是通过使用描述对象和数据库之间映射的元数据,在我们想到描述的时候自然就想到了xml和特性(Attribute).目前的ORM框架中,Hibernate就是典型的使用xml文件作为描述实体对象的映射框架,而大名鼎鼎的Linq则是使用特性(Attribute)来描述的。

### **26. hibernate 中如何在控制台查看打印的 SQL 语句？**

在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。

**示例：**

找到hibernate的配置文件-- hibernate.cfg.xml
加入：
<property name="hibernate.show_sql">true</property>

如果你用spring那么就要：

修改spring里面的配置文件：

...

<property name="hibernateProperties">

<props>

<prop key = "hibernate.dialect">org.hibernate.dialect.MySQLDialect</prop>

<prop key = "hibernate.show_sql">false</prop>

### **27. hibernate 有几种查询方式？**

Hibernate有4种查询方法。

HQL 通过Hibernate提供的查询语言进行查询。Hibernate Query lanague

EJBQL(JPQL 1.0) 是EJB提供的查询语言

QBC(query by cretira)通过Cretira接口进行查询

QBE(query by Example) 通过Example编程接口进行查询

从功能强弱上排序：NativeSQL > HQL > EJBQL(JPQL 1.0) >QBC(query by cretira) >QBE(query by Example) 1: QBE (Query By Example) QBC查询方式。

QBC(Query By Criteria)查询方式是 Hibernate 提供的“ 更加面向对象”的一种检索方式。 QBC 在条件查询上比 HQL 查询更为灵活，而且支持运行时动态天生查询语句。

在Hibernate 应用中使用 QBC 查询通常经过 3 个步骤：

(1)使用 Session 实例的 createCriteria() 方法创建 Criteria 对象

(2)使用工具类 Restrictions 的相关方法为 Criteria 对象设置查询对象

(3)使用 Criteria 对象的 list() 方法执行查询，返回查询结果QBE查询QBE查询就是检索与指定样本对象具有相同属性值的对象。因此QBE 查询的关键就是样本对象的创建，样本对象中的所有非空属性均将作为查询条件。 QBE 查询的功能子集，固然 QBE 没有 QBC 功能大，但是有些场合 QBE 使用起来更为方便。

工具类Example 为 Criteria 对象指定样本对象作为查询条件Java代码：

```java
1 Session session = HibernateSessionFactory.getSessionFactory().openSe ssion();
2 Transaction ts = session.beginTransaction();
3 Customer c = new Customer();
4 c.setCname("Hibernate");
5 Criteria criteria = session.createCriteria(Customer. class );
6 Criteria.add(Example.create(c));
7 Iterator it = criteria.list().iterator();
8 ts.commit();
9 HibernateSessionFactory.closeSession();
```

### **28. hibernate 实体类可以被定义为 final 吗？**

是的，你可以将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，如此一来就限制了使用可以提升性能的手段。不过，如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有public的方法轮到话，你就能够避免出现前面所说的不利后果。

### **29.** hibernate里实体类用int和Integer区别

返回数据库字段值是null的话，int类型会报错。int是基本数据类型，其声明的是变量，而null则是对象。所以hibernate实体建议用integer；

通过jdbc将实体存储到数据库的操作通过sql语句，基本数据类型可以直接存储，对象需要序列化存储。

在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。

如何序列化

```java
  ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(new File("E:/Person.txt")));
      oo.writeObject(person);
   ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File("E:/Person.txt")));
      Person person = (Person) ois.readObject();
```

### **30. hibernate 是如何工作的？**

1.通过Configuration config = new Configuration().configure();[//读取并解析hibernate.cfg.xml配置文件](https://link.zhihu.com/?target=//%E8%AF%BB%E5%8F%96%E5%B9%B6%E8%A7%A3%E6%9E%90hibernate.cfg.xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)

2.由hibernate.cfg.xml中的<mapping resource="com/xx/User.hbm.xml"/>读取并解析映射信息

3.通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory

4.Session session = sf.openSession();//打开Sesssion

5.Transaction tx = session.beginTransaction();//创建并启动事务Transation

6.persistent operate操作数据，持久化操作

7.tx.commit();//提交事务

8.关闭Session

9.关闭SesstionFactory

### **31. get()和 load()的区别？**

· 数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。

· load()支持延迟加载；get() 不支持延迟加载。

### **32. 说一下 hibernate 的缓存机制？**

hibernate 常用的缓存有一级缓存和二级缓存：

一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；

二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。

### **33. hibernate 对象有哪些状态？**

· 临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。

· 持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。

· 游离状态：Session 关闭之后对象就是游离状态。

### **34. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？**

· getCurrentSession 会绑定当前线程，而 openSession 则不会。

· getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。

### **35. hibernate 实体类必须要有无参构造函数吗？为什么？**

hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。

## Hibernate

**113. 为什么要使用 hibernate？**

- 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。
- Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作
- hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。
- hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。

**114. 什么是 ORM 框架？**

对象-关系映射（Object-Relational Mapping，简称ORM），面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射.

**115. hibernate 中如何在控制台查看打印的 sql 语句？**

参考：[blog.csdn.net/Randy_Wang_/article/details/79460306](http://blog.csdn.net/Randy_Wang_/article/details/79460306)

**116. hibernate 有几种查询方式？**

- hql查询
- sql查询
- 条件查询

```java
hql查询，sql查询，条件查询

HQL:  Hibernate Query Language. 面向对象的写法:
Query query = session.createQuery("from Customer where name = ?");
query.setParameter(0, "苍老师");
Query.list();



QBC:  Query By Criteria.(条件查询)
Criteria criteria = session.createCriteria(Customer.class);
criteria.add(Restrictions.eq("name", "花姐"));
List<Customer> list = criteria.list();



SQL:
SQLQuery query = session.createSQLQuery("select * from customer");
List<Object[]> list = query.list();

SQLQuery query = session.createSQLQuery("select * from customer");
query.addEntity(Customer.class);
List<Customer> list = query.list();



Hql： 具体分类
1、 属性查询 2、 参数查询、命名参数查询 3、 关联查询 4、 分页查询 5、 统计函数



HQL和SQL的区别

HQL是面向对象查询操作的，SQL是结构化查询语言 是面向数据库表结构的

1234567891011121314151617181920212223242526272829303132333435
```

**117. hibernate 实体类可以被定义为 final 吗？**

可以将Hibernate的实体类定义为final类，但这种做法并不好。因为Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，如此一来就限制了使用可以提升性能的手段。不过，如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有public的方法轮到话，你就能够避免出现前面所说的不利后果。

**118. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？**

在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。

**119. hibernate 是如何工作的？**

hibernate工作原理：
![在这里插入图片描述](F:\PROJECT\myGit\image\images\20190403231419411.png)**120. get()和 load()的区别？**

- load() 没有使用对象的其他属性的时候，没有SQL 延迟加载
- get() 没有使用对象的其他属性的时候，也生成了SQL 立即加载

**121. 说一下 hibernate 的缓存机制？**

Hibernate中的缓存分为一级缓存和二级缓存。

一级缓存就是 Session 级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是 SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。保存数据库后，缓存在内存中保存一份，如果更新了数据库就要同步更新。

什么样的数据适合存放到第二级缓存中？
![在这里插入图片描述](F:\PROJECT\myGit\image\images\20190403231533818.png)
扩展：hibernate的二级缓存默认是不支持分布式缓存的。使用 memcahe,redis等中央缓存来代替二级缓存。

**122. hibernate 对象有哪些状态？**

hibernate里对象有三种状态：

1. Transient（瞬时）：对象刚new出来，还没设id，设了其他值。
2. Persistent（持久）：调用了save()、saveOrUpdate()，就变成Persistent，有id。
3. etached（脱管）：当session close()完之后，变成Detached。

![在这里插入图片描述](F:\PROJECT\myGit\image\images\20190403231622847.png)
**123. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？**

openSession 从字面上可以看得出来，是打开一个新的session对象，而且每次使用都是打开一个新的session，假如连续使用多次，则获得的session不是同一个对象，并且使用完需要调用close方法关闭session。

getCurrentSession ，从字面上可以看得出来，是获取当前上下文一个session对象，当第一次使用此方法时，会自动产生一个session对象，并且连续使用多次时，得到的session都是同一个对象，这就是与openSession的区别之一，简单而言，getCurrentSession 就是：如果有已经使用的，用旧的，如果没有，建新的。

注意：在实际开发中，往往使用getCurrentSession多，因为一般是处理同一个事务（即是使用一个数据库的情况），所以在一般情况下比较少使用openSession或者说openSession是比较老旧的一套接口了。

1. hibernate 实体类必须要有无参构造函数吗？为什么？

必须，因为hibernate框架会调用这个默认构造方法来构造实例对象，即Class类的newInstance方法，这个方法就是通过调用默认构造方法来创建实例对象的。

另外再提醒一点，如果你没有提供任何构造方法，虚拟机会自动提供默认构造方法（无参构造器），但是如果你提供了其他有参数的构造方法的话，虚拟机就不再为你提供默认构造方法，这时必须手动把无参构造器写在代码里，否则new Xxxx()是会报错的，所以默认的构造方法不是必须的，只在有多个构造方法时才是必须的，这里“必须”指的是“必须手动写出来”。



**问：hibernate六大接口**

答：1)Configuration接口:负责配置并启动Hibernate

2)SessionFactory接口:负责初始化Hibernate

3)Session接口:负责持久化对象的CRUD操作

4)Transaction接口:负责事务

5)Query接口和Criteria接口:负责执行各种数据库查询



**问：hibernate处理过程**

答：1)通过Configuration config = new Configuration().configure();[//读取并解析hibernate.cfg.xml配置文件](https://link.zhihu.com/?target=//%E8%AF%BB%E5%8F%96%E5%B9%B6%E8%A7%A3%E6%9E%90hibernate.cfg.xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)

2)由hibernate.cfg.xml中的<mapping resource="com/xx/User.hbm.xml"/>读取并解析映射信息

3)通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory

4)Session session = sf.openSession();//打开Sesssion

5)Transaction tx = session.beginTransaction();//创建并启动事务Transation

6)persistent operate操作数据,持久化操作

7)tx.commit();//提交事务

8)session.close();关闭Session

9)sf.close()关闭SesstionFactory



**问：事务的特性**

答：1)原子性(atomic),事务必须是原子工作单元；对于其数据修改,要么全都执行,要么全都不执行

2)一致性(consistent),事务在完成时,必须使所有的数据都保持一致状态

3)隔离性(insulation),由并发事务所作的修改必须与任何其它并发事务所作的修改隔离

4)持久性(Duration),事务完成之后,它对于系统的影响是永久性的



**问：数据库事务并发可能带来的问题**

答：1)第一类丢失更新(lost update)： 在完全未隔离事务的情况下,两个事物更新同一条数据资源某一事物异常终止,回滚造成第一个完成的更新也同时丢失。

2)脏读(dirty read)：如果第二个事务查询到第一个事务还未提交的更新数据,形成脏读

3)不可重复读(unrepeated read)：一个事务两次读取同一行数据,结果得到不同状态结果如中间正好另一个事务更新了该数据,两次结果相异,不可信任

4) 第二类丢失更新(second lost updates)：是不可重复读的特殊情况,如果两个事务都读取同一行,然后两个都进行写操作,并提交,第一个事务所做的改变就会丢失



**问：为了解决数据库事务并发运行时的各种问题数据库系统提供四种事务隔离级**

答：1)Serializable 串行化

2)Repeatable Read 可重复读

3)Read Commited 可读已提交

4)Read Uncommited 可读未提交



**问：Hibernate悲观锁解决事务并发问题**

答：一个典型的依赖数据库的悲观锁调用：select * from account where name="Erica" for update这条sql语句锁定了account表中所有符合检索条件name=Erica的记录



**问：Hibernate为乐观锁提供了3中实现**

答：1)基于version

2)基于timestamp

3)为遗留项目添加添加乐观锁



**问：Hibernate 的缓存体系**

答：1)一级缓存： Session 有一个内置的缓存,其中存放了被当前工作单元加载的对象,每个Session 都有自己独立的缓存,且只能被当前工作单元访问

2)二级缓存： SessionFactory的外置的可插拔的缓存插件。其中的数据可被多个Session共享访问SessionFactory的内置缓存：存放了映射元数据,预定义的Sql语句



**问：Hibernate 中Java对象的状态**

答：1)临时状态(transient)特征：不处于Session 缓存中,数据库中没有对象记录,

Java如何进入临时状态

通过new语句刚创建一个对象时

当调用Session 的delete()方法

从Session 缓存中删除一个对象时

2)持久化状态(persisted)特征:处于Session 缓存中,持久化对象数据库中设有对象记录,Session 在特定时刻会保持二者同步

Java如何进入持久化状态

Session 的save()把临时－》持久化状态

Session 的load(),get()方法返回的对象

Session 的find()返回的list集合中存放的对象

Session 的update(),saveOrupdate()使游离－》持久化

3)游离状态(detached)特征:不再位于Session 缓存中,游离对象由持久化状态转变而来,数据库中可能还有对应记录

Java如何进入持久化状态－》游离状态

Session 的close()方法

Session 的evict()方法,从缓存中删除一个对象



**问：Hibernate中get和load有什么不同之处**

答：1)Hibernate的get方法,会确认一下该id对应的数据是否存在,首先在session缓存中查找然后在二级缓存中查找,还没有就查询数据库,数据库中没有就返回null

2)Hibernate的load方法加载实体对象的时候,根据映射文件上类级别的lazy属性的配置(默认为true)：

①若为true,则首先在Session缓存中查找,看看该id对应的对象是否存在,不存在则使用延迟加载

返回实体的代理类对象(该代理类为实体类的子类,由CGLIB动态生成)。等到具体使用该对象(除获取OID以外)的时候

再查询二级缓存和数据库,若仍没发现符合条件的记录,则会抛出一个ObjectNotFoundException

②若为false,就跟Hibernate的get方法查找顺序一样,只是最终若没发现符合条件的记录

则会抛出一个ObjectNotFoundException,所说的load方法抛异常是指在使用该对象的数据时

数据库中不存在该数据时抛异常,而不是在创建这个对象时



**问：Hibernate中save、update和saveOrUpdate方法的不同之处**

答：1)save：执行保存操作的,对一个新new出来的对象进行保存,数据库中没有这个对象,如果数据库中有,会报错说有重复的记录

2)update：如果是对一个已经存在的托管对象进行更新,要使用update方法了,数据中有这个对象

3)saveOrUpdate：这个方法是更新或者插入,有主键就执行更新,如果没有主键就执行插入。是根据实体类对象的状态做的不同操作

①实体类对象为临时态时做的添加save操作

②实体类对象为游离态、持久态时做的修改update操作



**问：cascade关系有以下几种**

答：1)all: 所有情况下均进行关联操作,即save-update和delete

　　2)none: 所有情况下均不进行关联操作。这是默认值

　　3)save-update: 在执行save/update/saveOrUpdate时进行关联操作

　　4)delete: 在执行delete 时进行关联操作

　　5)all-delete-orphan: 当一个节点在对象图中成为孤儿节点时,删除该节点



**问：什么是懒加载**

答: 1)Lazy：延迟加载,在真正使用某个对象的时候才正真的去创建,即hibernate才会正真的发出sql语句去加载该对象

2)Lazy的有效期：只有在session打开的时候才有效；session关闭后lazy就没效了

lazy策略可以用在：

①<class>标签上：可以取值true/false

②<property>标签上,可以取值true/false,这个特性需要类增强



**问：Hibernate 中inverse的属性**

答：hibernate配置文件中有这么一个属性inverse,它是用来指定关联的控制方的inverse属性默认是false,若为false,则关联由自己控制,若为true,则关联
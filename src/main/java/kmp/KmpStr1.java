package kmp;


/**
 * 假设有一个主字符串,一个子字符串,如何才能知道 主字符串是否包含子字符串?
 * kmp搜索: O(M+N)的时间复杂度
 * 目的: 主串无需从头开始匹配
 */
public class KmpStr1 {

    public static void main(String[] args) {
        String p = "abcdabcg";
        int[] nxt = buildNxtArr(p);
        String str = "absdwwscabcdabcgf";
//        kmpSearch(nxt, str, p);
        slowSearch(str, p);

    }


    /**
     *  例如: a b c d a b c g
     *
     *  是否含有相同的前缀和后缀?
     *      a b c d a b c g
     *      |-- |
     *      并不含有相同的前缀和后缀,所以下一次匹配需要从0开始
     */

    /**
     * KMP算法核心在于 构建 Nxt数组,计算失配表,也就是字符模版匹配表
     * 要点:   int j = 0, i = 1; 下标 j  从0开始, 下标 i 从1开始
     * 当 arr[i] = arr[j], j = j + 1;
     * <p>
     * 1. 在匹配子串的时候,已经匹配过的则直接跳过
     * (例如: 子串为 "abab", 匹配串为: "ababc",匹配串在 匹配到 c的时候,子串则不从0开始,从 index = 2开始匹配,节省时间)
     * 2. 第n位匹配出错之后，说明前n－1位都是匹配相同的,寻找是否有相同的前缀和后缀,
     *
     * @return
     */
    public static int[] buildNxtArr(String pattern) {
        char[] paChat = pattern.toCharArray();
        // 该数组是 前缀和后缀匹配成功的数组
        int[] nxtArr = new int[paChat.length];
        // j 是 匹配成功就 + 1,同时也是匹配的下标
        int j = 0, idx = 0;
        for (int i = 1; i < paChat.length; ) {
            char ci = paChat[i];
            char cj = paChat[j];
            if (ci == cj) {
                j++;
                nxtArr[i] = j;
                i++;
            } else if (j != 0) {
                /**
                 *  是否有相同的前后缀判断,当 j != 0 的时候,代表已经有共同的前后缀,则从前缀的上一位再去匹配
                 *    当已经有匹配成功的字符,当前的字符却不匹配的时候,则将 上一次的匹配成功的值 重新赋给 j 后,
                 *              j 不仅是是匹配表成功的值,同时也是匹配成功的 下标索引值,例如  paChat[i] =  paChat[j]
                 *    j = 上一次匹配成功的值 - 1, 左移一位
                 *     nxtArr[j - 1] 就是左移一位的匹配成功的值再赋值给 j ,如果大于0 则代表有公共前后缀,没有则为0
                 */
                j = nxtArr[j - 1];
            } else {
                nxtArr[i] = 0;
                i++;
            }
        }
        return nxtArr;
    }


    public static void kmpSearch(int[] nxtArr, String str, String c) {
        char[] strArr = str.toCharArray();
        char[] cArr = c.toCharArray();
        int i = 0;
        int j = 0;
        int success = 0;
        while (i < strArr.length && j < nxtArr.length) {
            char s = strArr[i];
            char cc = cArr[j];
            if (s == cc) {
                i++;
                if (j != nxtArr.length - 1) {
                    j++;
                } else {
                    success = j;
                }
            } else {
                if (j != 0) {
                    //取上一次匹配成功的值
                    j = nxtArr[j - 1];
                } else {
                    i++;
                }
            }

        }
        if (success == nxtArr.length - 1) {
            System.out.println("已经寻找到到,success = " + success);
        }
    }


    /**
     * 满搜索
     */
    public static void slowSearch(String str, String c) {
        char[] strArr = str.toCharArray();
        char[] cArr = c.toCharArray();
        int i = 0;
        int j = 0;
        int k = 0;
        while (i < strArr.length && j < c.length()) {
            char s = strArr[i];
            char cj = cArr[j];
            if (s == cj) {
                i++;
                j++;
            } else {
                j = 0;
                k++;
                i = k;
            }
        }
        if (j == cArr.length) {
            System.out.println("已经寻找到到,j = " + j);
        }
    }

}

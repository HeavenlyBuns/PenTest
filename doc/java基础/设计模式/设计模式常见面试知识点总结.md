# 设计模式常见面试知识点总结

创建型模式

创建型模式 创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。

## 单例

1. `单例模式保证全局的单例类只有一个实例，这样的话使用的时候直接获取即可，比如数据库的一个连接，Spring里的bean，都可以是单例的。`
2. 
3. `单例模式一般有5种写法。`
4. 
5. `第一种是饿汉模式，先把单例进行实例化，获取的时候通过静态方法直接获取即可。缺点是类加载后就完成了类的实例化，浪费部分空间。`
6. 
7. `第二种是饱汉模式，先把单例置为null，然后通过静态方法获取单例时再进行实例化，但是可能有多线程同时进行实例化，会出现并发问题。`
8. 
9. `第三种是逐步改进的方法，一开始可以用synchronized关键字进行同步，但是开销太大，而后改成使用volatile修饰单例，然后通过一次检查判断单例是否已初始化，如果未初始化就使用synchronized代码块，再次检查单例防止在这期间被初始化，而后才真正进行初始化。`
10. 
11. `第四种是使用静态内部类来实现，静态内部类只在被使用的时候才进行初始化，所以在内部类中进行单例的实例化，只有用到的时候才会运行实例化代码。然后外部类再通过静态方法返回静态内部类的单例即可。`
12. 
13. `第五种是枚举类，枚举类的底层实现其实也是内部类。枚举类确保每个类对象在全局是唯一的。所以保证它是单例，这个方法是最简单的。`

## 工厂模式

1. `简单工厂一般是用一个工厂创建多个类的实例。`
2. 
3. `工厂模式一般是指一个工厂服务一个接口，为这个接口的实现类进行实例化`
4. 
5. `抽象工厂模式是指一个工厂服务于一个产品族，一个产品族可能包含多个接口，接口又会包含多个实现类，通过一个工厂就可以把这些绑定在一起，非常方便。`

## 原型模式

1. `一般通过一个实例进行克隆从而获得更多同一原型的实例。使用实例的clone方法即可完成。`

## 建造者模式

1. `建造者模式中有一个概念叫做链式调用，链式调用为一个类的实例化提供便利，一般提供系列的方法进行实例化，实际上就是将set方法改造一下，将原本返回为空的set方法改为返回this实例，从而实现链式调用。`
2. 
3. `建造者模式在此基础上加入了builder方法，提供给外部进行调用，同样使用链式调用来完成参数注入。`

## 结构型模式

1. `结构型模式`
2. 
3. `前面创建型模式介绍了创建对象的一些设计模式。`
4. 
5. `这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。`

## 桥接模式

1. `有点复杂。建议参考原文`

## 适配器模式

1. `适配器模式用于将两个不同的类进行适配。`
2. 
3. `适配器模式和代理模式的异同`
4. 
5. `比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，`
6. `它们很相似，都需要一个具体的实现类的实例。`
7. `但是它们的目的不一样，代理模式做的是增强原方法的活；`
8. `适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，`
9. `而鸡和鸭它们之间原本没有继承关系。`
10. 
11. `适配器模式可以分为类适配器，对象适配器等。`
12. 
13. `类适配器通过继承父类就可以把自己适配成父类了。`
14. `而对象适配器则需要把对象传入另一个对象的构造方法中，以便进行包装。`

## 享元模式

1. `享元模式的核心在于享元工厂类，`
2. 
3. `享元工厂类的作用在于提供一个用于存储享元对象的享元池，`
4. 
5. `用户需要对象时，首先从享元池中获取，`
6. 
7. `如果享元池中不存在，则创建一个新的享元对象返回给用户，`
8. 
9. `在享元池中保存该新增对象。`

## 代理模式

1. `我们发现没有，代理模式说白了就是做 “方法包装” 或做 “方法增强”。`
2. 
3. `在面向切面编程中，算了还是不要吹捧这个名词了，在 AOP 中，`
4. 
5. `其实就是动态代理的过程。比如 Spring 中，`
6. `我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，`
7. 
8. `然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。`

## 外观模式

1. `外观模式一般封装具体的实现细节，为用户提供一个更加简单的接口。`
2. 
3. `通过一个方法调用就可以获取需要的内容。`

## 组合模式

1. `组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。`
2. 
3. `直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，`
4. 
5. `同时还有下属员工集合（虽然可能集合为空），`
6. `而下属员工和自己的结构是一样的，`
7. 
8. `也有姓名、部门这些属性，`
9. `同时也有他们的下属员工集合。`
10. 
11. `class Employee {`
12. `private String name;`
13. `private String dept;`
14. `private int salary;`
15. `private List subordinates; // 下属`
16. `}`

## 装饰者模式

## 装饰者

装饰者模式把每个增强类都继承最高级父类。然后需要功能增强时把类实例传入增强类即可，然后增强类在使用时就可以增强原有类的功能了。

和代理模式不同的是，装饰者模式每个装饰类都继承父类，并且可以进行多级封装。

## 行为型模式

1. `行为型模式`
2. 
3. `行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。`

## 策略模式

1. `策略模式一般把一个策略作为一个类，并且在需要指定策略的时候传入实例，于是我们可以在需要使用算法的地方传入指定算法。`

## 命令模式

1. `命令模式一般分为命令发起者，命令以及命令接受者三个角色。`
2. 
3. `命令发起者在使用时需要注入命令实例。然后执行命令调用。`
4. 
5. `命令调用实际上会调用命令接收者的方法进行实际调用。`
6. 
7. `比如遥控器按钮相当于一条命令，点击按钮时命令运行，自动调用电视机提供的方法即可。`

## 模板方法模式

1. `模板方法一般指提供了一个方法模板，并且其中有部分实现类和部分抽象类，并且规定了执行顺序。`
2. 
3. `实现类是模板提供好的方法。而抽象类则需要用户自行实现。`
4. 
5. `模板方法规定了一个模板中方法的执行顺序，非常适合一些开发框架，于是模板方法也广泛运用在开源框架中。`

## 观察者模式和事件监听机制

1. `观察者模式一般用于订阅者和消息发布者之间的数据订阅。`
2. 
3. `一般分为观察者和主题，观察者订阅主题，把实例注册到主题维护的观察者列表上。`
4. 
5. `而主题更新数据时自动把数据推给观察者或者通知观察者数据已经更新。`
6. 
7. `但是由于这样的方式消息推送耦合关系比较紧。并且很难在不打开数据的情况下知道数据类型是什么。`
8. 
9. `知道后来为了使数据格式更加灵活，使用了事件和事件监听器的模式，事件包装的事件类型和事件数据，从主题和观察者中解耦。`
10. 
11. `主题当事件发生时，触发该事件的所有监听器，把该事件通过监听器列表发给每个监听器，监听得到事件以后，首先根据自己支持处理的事件类型中找到对应的事件处理器，再用处理器处理对应事件。`

## 责任链模式

1. `责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。`
2. 
3. `比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。`





# 设计模式你真的懂了吗？



![img](http://zhaojiaxing.gitee.io/image/images/16878a2a3889df3a)



### 前言

`设计模式`这个老生常谈的东西，在以往的面试题以及面试中会经常问到，关于设计模式，网上有很多文章对其进行阐述。

但是看了那么多设计模式你真的懂了吗？

在项目中除了单例模式，你还用到了哪些设计模式呢？

各个设计模式又有什么利弊呢？如何去正确的考量呢？

在这里，我只是通过自己的理解，把我所知道的写出来,文章很长，建议先收藏起来，慢慢看（ps：`_(:з」∠)_`轻喷）。

### —、设计模式的分类

总的来说，设计模式分为三种：创建模式、结构模式、行为模式

#### 1. 创建模式

创建模式：提供实例化的方法，为适合的状况提供相应的对象创建方法。 其中属于创建模式的是：单例模式、建造者模式、工厂方法模式、抽象工厂模式、原型模式。

##### 1.单例模式（Singleton Pattern）

定义：确保一个类中有且只有一个实例，而且自行实例化。 这里可以去看我之前写的[如何写出一个好的单例模式](https://juejin.im/post/5c47d8faf265da61171d093f)

##### 2.建造者模式 （Builder Pattern）

定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 更多内容请看 [浅析builder模式](https://lennyup.github.io/2017/04/20/android-builder/)

##### 3.工厂方法模式（Factory Method Pattern）

定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。 下面引入一个简单工厂模式： 肉制品加工厂加工不同的肉制品。

```
//定一个抽象方法用来生产肉制品
abstract class Product {
	public abstract void method();
}
class MuttonProduct extends Product {
	@Override
	public void mothod() {
		System.out.println("生产出来了羊肉....");
	}
}
class PorkProduct extends Product {
	@Override
	public void mothod() {
		System.out.println("生产出来了猪肉....");
	}
}
abstract class Creator {
	public abstract <T extends Product> T createProduce(Class<T> product);
}

class OneCreator extends Creator{
	/**
	 * 传入的参数，是Product类的子类。
	 */
	@Override
	public <T extends Product> T createProduce(Class<T> product) {
		Product p = null;
		try {
			//Class类创建一个 工厂类实例
			p = (Product) Class.forName(product.getName()).newInstance();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return (T) p;
	}
}

public class Test {
	public static void main(String[] args) {
		//通过创建子类对象，将接口实例化。
		Creator cFactory = new OneCreator();
		//通过子类的方法，创建一个需要的对象。
		ForkProduct food  = cFactory.createProduce(ForkProduct.class);
		food.mothod();
	}
}
复制代码
```

Product, 抽象类，表示不同的肉制品。

PorkProduct,实现类，继承Product。

MuttonProduct，同上。

Creator抽象工厂类，提供加工方法。

OneCreator实现类，加工不同的肉制品。

工厂模式的优点：

1. 代码机构清晰，有很好的封装性。降低了模块间的耦合性。
2. 有很好的扩展性。
3. 屏蔽产品类，产品类对外提供的是一个接口，只要接口不改变系统中的上层模块就不会发生改变。

\#####扩展

###### 1.替代单例

```
class SingtonFactory {
	private static Singleton single;
	static {
		try {
			Class c = Class.forName(Singleton.class.getName());
			//获取无参构造
			Constructor<Singleton> constractor = c.getDeclaredConstructor();
			//设置无参构造是可访问的
			constractor.setAccessible(true);
			//产生一个实例对象
			single = constractor.newInstance();
		} catch (Exception e) {
			System.out.println("创建失败。。。")
		}
	}
	public Singleton getSingle() {
		return single;
	}
}

class Singleton {
	//构造私有化
	private Singleton {
	}
	public void method () {
		System.out.println("sington。。。。")
	}
}
复制代码
```

###### 2.延迟初始化

一个对象被使用完毕，并不立刻释放，保持其初始状态，等待再次被使用

```
interface Product {
	void method();
}
class MuttonProduct implements Product {
	@Override
	public void mothod() {
		System.out.println("生产出来了羊肉....");
	}
}
class PorkProduct implements Product {
	@Override
	public void mothod() {
		System.out.println("生产出来了猪肉....");
	}
}
abstract class Creator {
	public abstract <T extends Product> T createProduce(String type);
}

class OneCreator extends Creator{
	private static Map<String,Product> map = new HashMap<String,Product>();
	@Override
	public <T extends Product> T createProduce(String type) {
		Product p = null;
		if(map.containsKey(type)) {
			p = map.get(type);
		} else {
			if(type.equals("pork")) {
				p = new PorkProduct();
			} else {
				p = new MuttonProduct();
			}
		}
		map.put(type, p);
		return p;
	}
}

public class Test {
	public static void main(String[] args) {
		for(int i=0;i<5;i++){
			Product p = new OneCreator().createProduce("pork");
			p.mothod();
			System.out.println("------------------------------");
		}
	}
}
复制代码
```

##### 4.抽象工厂模式(Abstract Factory)

定义：为创建一组相关或相互依赖的对象提供一个接口，而且无须指定他们的具体类。

抽象工厂模式是工厂模式的升级版，针对的是多业务类型。

通用模式：



![img](http://zhaojiaxing.gitee.io/image/images/168789c387171f90)



```
public class MyClass {
    public static void main(String [] args) {
        IProduct p1 = new Creator1();
        ProductA1 a1 = (ProductA1) p1.createA();
        a1.method();
        IProduct p2 = new Creator();
        ProductB1 b1 = (ProductB1) p2.createB();
        b1.method();
    }
}

abstract class AbstractProductA {
    public void shareMethod (){
        System.out.println("生产产品共同的方法");
    }
    abstract void method();
}
abstract class AbstractProductB {
    public void shareMethod () {
        System.out.println("生产产品共同的方法");
    }
    abstract void method();
}
interface IProduct {
    AbstractProductA createA();
    AbstractProductB createB();
}
class ProductA1 extends AbstractProductA {

    @Override
    void method() {
        System.out.println("生产A1");
    }
}
class ProductA2 extends AbstractProductA {

    @Override
    void method() {
        System.out.println("生产A2");
    }
}
class ProductB1 extends AbstractProductB{

    @Override
    void method() {
        System.out.println("生产B1");
    }
}
class ProductB2 extends  AbstractProductB {

    @Override
    void method() {
        System.out.println("生产B2");
    }
}

class Creator1 implements IProduct{

    @Override
    public AbstractProductA createA() {
        return new ProductA1();
    }

    @Override
    public AbstractProductB createB() {
        return new ProductB2();
    }
}
class Creator implements IProduct {

    @Override
    public AbstractProductA createA() {
        return new ProductA2();
    }

    @Override
    public AbstractProductB createB() {
        return new ProductB1();
    }
}
复制代码
```

抽象工厂模式 一般是 一个接口，多个抽象类，n个实现类，从上面的代码可以看出它除了有工厂方法模式的优点外，还可以在类的内部对产品族进行约束。所谓产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。

抽象工厂模式的缺点也是显而易见的，就是产品族的扩展比较困难。

##### 5.原型模式

定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

java提供了一个Cloneable接口，来标示这个类是可拷贝的，通过该接口中的clone方法对对象进行拷贝。

例子：某电商平台双十一搞活动，需要群发邮件通知。

```
class MyClass {
    public static void main(String [] args) {
        Mail mail = new Mail(new Template());
        for (int i = 0 ;i < 100; i++) {
            try {
                Mail cMail = (Mail) mail.clone();
                cMail.setReceiver(getReceiver(6) + ".com");
                sendMail(cMail);
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
        }
    }

    private static void sendMail(Mail cMail) {
        System.out.println("收件人" + cMail.getReceiver() + "发送成功");
    }

    private static String getReceiver(int i) {
        String s = "abcdefghijklmnopqrstuvwxz";
        Random random = new Random();
        StringBuffer sb = new StringBuffer();
        for (int j =0 ;j <= i; j++) {
            sb.append(s.charAt(random.nextInt(s.length())));
        }
        return sb.toString();
    }
}

class Template {
    private String subject = "双十一优惠活动";
    private String context = "双十一优惠活动，全场满99减5元";

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }
}
class Mail implements Cloneable {
    // 收件人
    private String receiver;
    //标题
    private String subject;
    // 内容
    private String context;

    public Mail(Template template) {
        this.subject = template.getSubject();
        this.context = template.getContext();
    }

    public String getReceiver() {
        return receiver;
    }

    public void setReceiver(String receiver) {
        this.receiver = receiver;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }
    // 重写 clone
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Mail mail = (Mail) super.clone();
        return mail;
    }
}
复制代码
```

原型模式是内存二进制流的法拷贝，比new一个新的对象好的多。

原型模式是从内存中拷贝，构造函数是不会执行的。拷贝分为浅拷贝和深拷贝，浅拷贝只是拷贝对象，其对象内部的数组、引用对象都不会拷贝。

原型模式需要注意的是：出现final的对象或变量，不能clone

深拷贝的例子：

```
public class Prototype {
	public static void main(String[] args) {
			//创建一个对象
			MyClone myClone = new MyClone();
			myClone.setArrayList("abs");
			//将该对象clone。
			MyClone clone2 = (MyClone) myClone.clone();
			clone2.setArrayList("gh");
			//输出原对象的结果。
			System.out.println("原对象...."+myClone.getArrayList());
			//输出拷贝后的结果。
			System.out.println("拷贝结果...."+clone2.getArrayList());
	}
}
class MyClone implements Cloneable{
	private ArrayList<String> arrayList = new ArrayList<String>();
	@SuppressWarnings("unchecked")
	@Override
	public MyClone clone(){
		MyClone myClone =null;
		try {
			myClone = (MyClone) super.clone();
			//把私有对象也进行拷贝。做到深拷贝的效果
			myClone.arrayList = (ArrayList<String>) this.arrayList.clone();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return myClone;
	}
	public ArrayList<String> getArrayList() {
		return arrayList;
	}
	public void setArrayList(String name) {
		this.arrayList.add(name);
	}
	
}
复制代码
```

输出结果：

```
原对象....[abs]
拷贝结果....[abs, gh]
复制代码
```

#### 2.结构模式

结构模式：通常用来处理实体之间的关系，使得这些实体能够更好地协同工作。

其中属于结构模式的是：装饰模式、适配器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

##### 1.代理模式（Proxy Pattern）

定义： 为其他对象提供一种代理以控制对这个对象的访问。

例子：明星拍广告，要和经纪人沟通。

```
public class MyClass {
    public static void main(String [] args) {
        Agent mAgent = new Agent(new Star());
        mAgent.shootAdvertisement();
    }
}

interface Subject {
    public void shootAdvertisement();
}

class Star implements Subject {
    @Override
    public void shootAdvertisement() {
        System.out.println("拍广告。。。");
    }
}

class Agent implements Subject {
    // 经纪人 ，代理类
    private Subject star = null;
    // 设置被代理类
    public Agent(Subject star) {
        this.star = star;
    }

    @Override
    public void shootAdvertisement() {
        before();
        star.shootAdvertisement();
        after();
    }

    private void after() {
        System.out.println("处理拍广告之前的各项工作");
    }

    private void before() {
        System.out.println("处理拍广告之后的善后工作");
    }
}
复制代码
```

代理模式分为：

- 静态代理模式
  - 普通代理模式
  - 强制带离模式
- 动态代理模式

普通代理模式：要求客户端只能访问代理角色，而不能访问真实角色。

例子：游戏代练

```
public class MyClass {
    public static void main(String [] args) {
        GameProxy gameProxy = new GameProxy("Miss");
        gameProxy.login();
        gameProxy.upgrade();
    }
}

interface IGamePlayer {
    public void login();
    public void upgrade();
}

class GamePlayer implements IGamePlayer {
    public String name = "";

    public GamePlayer(IGamePlayer gamePlayer, String name) {
        if (gamePlayer == null) {
            try {
                throw new Exception("不能创建对象");
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            this.name = name;
        }
    }

    @Override
    public void login() {
        System.out.println(this.name + "-登录成功");
    }

    @Override
    public void upgrade() {
        System.out.println("升级了！！！！");
    }
}

class GameProxy implements IGamePlayer {
    private GamePlayer mGamePlayer = null;

    public GameProxy(String name) {
        this.mGamePlayer = new GamePlayer(this, name);

    }

    @Override
    public void login() {
        mGamePlayer.login();
    }

    @Override
    public void upgrade() {
        mGamePlayer.upgrade();
    }
}
复制代码
```

###### 强制代理

必须通过真实角色找到代理角色，否则无法访问

```
public class MyClass {
    public static void main(String [] args) {
        GamePlayer player = new GamePlayer("Miss");
        player.login();
        player.upgrade();
        GameProxy proxy = new GameProxy(player.getPlayer());
        proxy.login();
        proxy.upgrade();
    }
}

interface IGamePlayer {
    public void login();
    public void upgrade();
    IGamePlayer getPlayer();
}

class GamePlayer implements IGamePlayer {
    private IGamePlayer player;
    private String name;
    public GamePlayer(String name) {
        this.name = name;
    }

    private boolean isProxy() {
        if (this.player == null) {
            return false;
        } else {
            return true;
        }
    }

    @Override
    public void login() {
        if (this.isProxy()) {
            System.out.println(this.name + "-登录成功");
        } else {
            System.out.println("请使用代理访问");
        }
    }

    @Override
    public void upgrade() {
        if (this.isProxy()) {
            System.out.println("升级了！！！！");
        } else {
            System.out.println("请使用代理访问");
        }
    }

    @Override
    public IGamePlayer getPlayer() {
        this.player = new GameProxy(this);
        return this.player;
    }
}

class GameProxy implements IGamePlayer {
    private IGamePlayer gamePlayer;

    public GameProxy(IGamePlayer gamePlayer) {
        this.gamePlayer = gamePlayer;
    }

    @Override
    public void login() {
        this.gamePlayer.login();
    }

    @Override
    public void upgrade() {
        this.gamePlayer.upgrade();
    }

    @Override
    public IGamePlayer getPlayer() {
        return this;
    }
}
复制代码
```

输出结果：

```
请使用代理访问
请使用代理访问
Miss-登录成功
升级了！！！！
复制代码
```

###### 动态代理

动态代理：实现阶段不用关系代理是哪个，而在运行阶段指定具体哪个代理。

```
public class MyClass {
    public static void main(String [] args) {
        IGamePlayer mGamePlayer = new GamePlayer("Miss");
        InvocationHandler handler = new GameProxy(mGamePlayer);
        //生成一个代理者
        // ClassLoader: 指定当前目标对象使用类加载器
        // Class<?> [] interface: 目标对象实现接口的类型
        // InvocationHandler: 事件处理，执行目标对象的方法时，会触发事件处理器的方法。
        IGamePlayer player = (IGamePlayer) Proxy.newProxyInstance(mGamePlayer.getClass().getClassLoader(), new Class[]{IGamePlayer.class}, handler);
        player.login("Miss", "123456a");
        player.upgrade();
    }
}

interface IGamePlayer {
    public void login(String name, String password);
    public void upgrade();
}

class GamePlayer implements IGamePlayer {
    private String name = "";

    public GamePlayer(String name) {
        this.name = name;
    }

    @Override
    public void login(String name, String password) {
        System.out.println(name + "登录成功");
    }

    @Override
    public void upgrade() {
        System.out.println(this.name + "升级了");
    }
}

class GameProxy implements InvocationHandler {
	// 被代理的对象
    private Object obj;
	// 将需要代理的实例通过构造方法传递给代理
    public GameProxy(Object obj) {
        this.obj = obj;
    }

    @Override
    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
        if (method.getName().equalsIgnoreCase("login")) {
        // 在这个方法不收影响的情况下，在方法的前后添加新的功能
        // 从侧面切入从而达到扩展的效果的编程，就是面向切面编程（AOP Aspect Oriented Programming）				
            System.out.println("代理登录了");
            Object result = method.invoke(this.obj, objects);
            return  result;
        }
        Object result = method.invoke(this.obj, objects);
        return  result;
    }
}
复制代码
```

动态代理模式的一般模式：

```
public class MyClass {
    public static void main(String [] args) {
        Subject subject = new MySubject();
        InvocationHandler handler = new MyInvocationHandler(subject);
        ClassLoader loader = subject.getClass().getClassLoader();
        Class <?>[] in = subject.getClass().getInterfaces();
        Subject s = DynamicProxy.newProxyInstance(loader, in, handler);
        s.doSomething();
    }
}

interface Subject {
    void doSomething();
}
class MySubject implements Subject {
    @Override
    public void doSomething() {
        System.out.println("吃饭睡觉打豆豆");
    }
}
interface Advice {
    public void exec();
}
class BeforeAdvice implements Advice {
    @Override
    public void exec() {
        System.out.println("前置方法");
    }
}
class AfterAdvice implements Advice {
    @Override
    public void exec() {
        System.out.println("后置方法");
    }
}
class MyInvocationHandler implements InvocationHandler {
    private Subject mySubject;

    public MyInvocationHandler(Subject mySubject) {
        this.mySubject = mySubject;
    }

    @Override
    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {
        Advice beforeAdvice = new BeforeAdvice();
        beforeAdvice.exec();
        Object result = method.invoke(this.mySubject, objects);
        Advice afterAdvice = new AfterAdvice();
        afterAdvice.exec();
        return result;
    }
}
class DynamicProxy {
    public static <T> T newProxyInstance(ClassLoader classLoader, Class<?>[] interfaces, InvocationHandler handler){
        @SuppressWarnings("unchecked")
        T t = (T) Proxy.newProxyInstance(classLoader, interfaces, handler);
        return t;
    }
}
复制代码
```

##### 2.装饰模式（Decorator Pattern）

定义：动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更佳灵活

###### 模式中的角色

- 抽象构建（Component）：定义个个抽象接口，用于给对象动态的添加职责。
- 具体构建（ConcreteComponent）：定义一个具体的对象，也可以给这个对象添加一些职责。
- 装饰类（Decorator）：装饰抽象类。继承了Component，从外类来扩展Component类的功能。
- 具体装饰类：（ConcretorDecorator）：负责给构建对象添加职责。

模式的一般模式：

```
public class MyClass {
    public static void main(String [] args) {
        Component component = new ConcreteComponent();
        ConcreteDecorator decorator = new ConcreteDecorator(component);
        decorator.doSomething();
    }
}

abstract class Component {
   public abstract void doSomething();
}
class ConcreteComponent extends Component {

    @Override
    public void doSomething() {
        System.out.println("具体实现的方法");
    }
}
abstract class Decorator extends Component {
    private Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void doSomething() {
        this.component.doSomething();
    }
}
class ConcreteDecorator extends Decorator {

    public ConcreteDecorator(Component component) {
        super(component);
    }

    @Override
    public void doSomething() {
        System.out.println("方法前要执行的动作");
        super.doSomething();
        System.out.println("方法后要执行的动作");
    }
}
复制代码
```

###### 装饰模式的优点

- 装饰类和被装饰类可以独立的发展，不会相互耦合。
- 装饰模式是继承关系的一种替代方案，Decorator不管修饰多少层，返回的对象还是Component，实现的还是is-a的关系。
- 装饰模式可以动态的扩展一个实现类的功能。

###### 装饰模式的缺点

- 多层的装饰模式是比较复杂的。

###### 装饰模式的使用场景

- 扩展一个类的功能，或给一个类增加附加的功能。
- 动态的给一个对象增加功能，这些功能可以动态的撤销。
- 为一些类进行改装或者增肌功能，首选装饰模式。

##### 3. 适配器模式

定义：将一个类的接口编程客户端所期待的另一个接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

适配器模式的一般模式：

```
public class MyClass {
    public static void main(String [] args) {
        Target target = new ConcreteTarget();
        target.doSomething();
        Target adapter = new Adapter();
        adapter.doSomething();
    }
}

interface Target {
    void doSomething();
}
class ConcreteTarget implements Target {

    @Override
    public void doSomething() {
        System.out.println("我是目标角色，现在要使用我的...");
    }
}
abstract class Adaptee {
    public void doSome () {
        System.out.println("我是源角色，从这里转变。。。");
    }
}
class Adapter extends Adaptee implements Target {

    @Override
    public void doSomething() {
        super.doSome();
    }
}
复制代码
```

适配器模式在android中比较常见，比如ListView的适配器。 例子：有两种插座：两孔的和三孔的。在一个宾馆里 只有两孔的插座，所有我们要做一些操作，让我们可以用三孔的插座

```
public class MyClass {
    public static void main(String [] args) {
        TSocketInterface socket = new ThreeSocket();
        Hotel hotel = new Hotel();
        SocketAdapter adapter = new SocketAdapter(socket);
        hotel.setSocket(adapter);
        hotel.charge();
    }
}

interface SocketInterface {
    void TwoRound();
}

class TwoSocket implements SocketInterface {

    @Override
    public void TwoRound() {
        System.out.println("使用两孔插座");
    }
}
interface TSocketInterface {
    void ThreeRound();
}
class ThreeSocket implements TSocketInterface {

    @Override
    public void ThreeRound() {
        System.out.println("使用三孔插座");
    }
}
class SocketAdapter implements SocketInterface {
    private TSocketInterface socket;

    public SocketAdapter(TSocketInterface socket) {
        this.socket = socket;
    }

    @Override
    public void TwoRound() {
        this.socket.ThreeRound();
    }
}
class Hotel {
    private SocketInterface socket;

    public void setSocket(SocketInterface socket) {
        this.socket = socket;
    }
    public void charge () {
        socket.TwoRound();
    }
}
复制代码
```

###### 适配器模式的特点

- 适配器对象实现原有接口
- 适配器对象组合一个实现新接口的对象
- 对适配器原有接口方法的调用被委托给新接口的实例的特定方法。

##### 4.外观模式

定义： 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。

例子：进门分为几个步骤：拿钥匙、开门、进房间。而关门的话，也需要差不多的步骤，这时就需要一个外观模式，通过一个合理的方式将这些动作包装起来。

```
public class MyClass {
    public static void main(String [] args) {
        Facade facade = new Facade(new Key(), new Door(), new House());
        facade.in();
        facade.out();
    }
}

class Key {
    public void takekey () {
        System.out.println("拿钥匙");
    }
}
class Door {
    public void openDoor () {
        System.out.println("开门");
    }
    public void closeDoor () {
        System.out.println("关门");
    }
}
class House {
    public void goIn () {
        System.out.println("进入房间");
    }
    public void goOut () {
        System.out.println("出房间");
    }
}
class Facade {
    private Key key;
    private Door door;
    private House house;

    public Facade(Key key, Door door, House house) {
        this.key = key;
        this.door = door;
        this.house = house;
    }
    public void in () {
        key.takekey();
        door.openDoor();
        house.goIn();
    }
    public void out () {
        key.takekey();
        house.goOut();
        door.closeDoor();
    }
}
复制代码
```

###### 外观模式的优点

- 减少系统的相互依赖
- 提高灵活性
- 提高安全性

###### 外观模式的缺点

- 不符合开闭原则

###### 使用场景

- 为一个复杂的模块后子系统提供一个供外界访问的接口
- 子系统相互独立，外界对子系统的访问只要黑箱操作就可以
- 预防低水平人员带来的风险扩散

##### 5.组合模式（Composite Pattern）

定义：将对象组合成树形结构表示“部分-整体”的层次结构。Composite模式使得用户对单个对象和组合对象的使用具有一致性。

###### 组成

- 抽象构件（Component）: 定义参与组合对象的共有方法和属性，可以定义一些默认行为或属性。
- 树叶构件（Leaf）：组合中叶子对象，其下没有其他分支，是最小的单位。
- 树枝构件（Composite）：在组合中表示分直接点对象，有子节点，存储子部件。

一般模式：

```
public class MyClass {
    public static void main(String [] args) {
        /**
         *           composite1
         *           /      \
         *        leaf1   composite2
         *                  /   \
         *               leaf2  leaf3
         *
         * */
        Component leaf1=new Leaf();
        Component leaf2=new Leaf();
        Component leaf3=new Leaf();
        Composite composite1=new Composite();
        Composite composite2=new Composite();

        composite2.add(leaf2);
        composite2.add(leaf3);
        composite1.add(leaf1);
        composite1.add(composite2);

        composite1.doSomething();
    }
}

interface Component {
    public void doSomething();
}

class Leaf implements Component {

    @Override
    public void doSomething() {
        System.out.println("Leaf doSomething");
    }
}
class Composite implements Component {
    List<Component> childs = new ArrayList<>();
    public void add (Component child) {
        this.childs.add(child);
    }
    public void remove(Component component) {
        this.childs.remove(component);
    }
    public Component getChild(int i) {
        return  this.childs.get(i);
    }
    @Override
    public void doSomething() {
        for (Component child : childs) {
            child.doSomething();
        }
    }
}
复制代码
```

###### 实现方式

- 透明式的组合模式：将管理子构件的方法定义在Component接口中，这样Leaf类就需要处理这些对其意义不大的方法，在接口层次上Leaf和Composite没有区别，这就是透明性。
- 安全式的组合模式：将管理子构件的方法定义在Composite中，这样编译时任何从Leaf中增加或删除对象的尝试都将会被发现。

###### 适用场景

- 忽略组合对象和单个对象的不同，用户将统一地使用组合结构中所有对象。
- 想表示对象的部分-整体层次结构。

##### 6.桥接模式

`定义`: 将抽象和实现解耦，使得两者之间可以独立的变化

桥接的用意是将抽象化和结构化解耦，使得二者可以独立变化，就像JDBC桥DriverManage一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不用改动太多代码，因为JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行。

一般模式：

```
public class MyClass {
    public static void main(String [] args) {
        Sourceable sourceable = new ConcreteSource1();
        Bridge bridge = new MyBridge(sourceable);
        bridge.method();
    }
}

interface Sourceable {
    public void doSomething();
    public void doAnything();
}
class ConcreteSource1 implements Sourceable {
    @Override
    public void doSomething() {
        System.out.println("this is first source doSomething");
    }

    @Override
    public void doAnything() {
        System.out.println("this is first source doAnything");
    }
}
class ConcreteSource2 implements Sourceable {

    @Override
    public void doSomething() {
        System.out.println("this is second doSomething");
    }

    @Override
    public void doAnything() {
        System.out.println("this is second doAnything");
    }
}

abstract class Bridge {
    private Sourceable sourceable;

    public Bridge(Sourceable sourceable) {
        this.sourceable = sourceable;
    }

    public Sourceable getSourceable() {
        return sourceable;
    }
    public void method () {
        sourceable.doSomething();
    }
}
class MyBridge extends Bridge {

    public MyBridge(Sourceable sourceable) {
        super(sourceable);
    }

    @Override
    public void method() {
        super.getSourceable().doAnything();
    }
}
复制代码
```

###### 桥接模式的优点：

- 抽象和实现分离
- 优秀的扩充能力
- 实现细节对客户透明

###### 桥接模式的使用场景

- 不希望或不适用使用继承的场景
- 接口或抽象不稳定的场景
- 重用性要求比较高的场景

##### 7.享元模式

`定义`：使用`共享对象`可有效的支持大量的`细粒度`的对象。

细粒度对象由于对象数量多且性质相近，我们将其分为两个部分：内部状态和外部状态。

- 内部状态：内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境而改变。如 id，adress等。
- 外部状态：对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。

一般模式：

- Flyweight: 抽象享元角色，定义出对象的外部状态和北部状态的接口或接口实现。
- ConcreteFlyweight 具体的享元角色，实现抽象角色定义的的义务。
- FlyweightFactory: 构造一个对象池，从池中提供对象。

```
public class MyClass {
    public static void main(String [] args) {
        FlyweightFactory.getFlyweight("Miss");
        FlyweightFactory.getFlyweight("Boss");
        FlyweightFactory.getFlyweight("Miss");
    }
}
abstract class Flyweight {
    //内部状态
   private String intrinsic;
    // 外部状态
    private String extrinsic;
    // 构造方法提供外部字符串
    public Flyweight(String extrinsic) {
        this.extrinsic = extrinsic;
    }

    public void setIntrinsic(String intrinsic) {
        this.intrinsic = intrinsic;
    }

    public String getIntrinsic() {
        return intrinsic;
    }
    public abstract void operate ();
}

class ConcreteFlyweight extends Flyweight {
    public ConcreteFlyweight(String extrinsic) {
        super(extrinsic);
    }

    @Override
    public void operate() {
        System.out.println("this is first operate  ");
    }
}
class  ContreteFlyweight2 extends Flyweight {

    public ContreteFlyweight2(String extrinsic) {
        super(extrinsic);
    }

    @Override
    public void operate() {
        System.out.println("this is second operate");
    }
}
// 享元工厂
class FlyweightFactory {
    private static Map<String, Flyweight> list = new HashMap<>();
    public static Flyweight getFlyweight (String extrinsic) {
        Flyweight flyweight = null;
        if (list.containsKey(extrinsic)) {
            System.out.println("从对象池中取对象。。");
            flyweight = list.get(extrinsic);
        } else {
            flyweight = new ConcreteFlyweight(extrinsic);
            list.put(extrinsic, flyweight);
            System.out.println("创建新对象。。");
        }
        return flyweight;
    }
}
复制代码
```

###### 享元模式优点：

减少应用创建的对象，降低使用内存，增强程序性能。

###### 适用场景

系统中存在很多相似对象，细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关。

#### 3.行为模式

行为模式：用于在不同的实体之间进行通信，为实体之间的通信提供更容易，更灵活的通信方法。

其中属于行为模式的是：观察者模式、策略模式、访问者模式、中介者模式、状态模式、备忘录模式、责任链模式、模版方法模式、迭代子模式、命令模式、解释器模式。

##### 1.观察者模式

`定义`：定义对象间一种一对多的依赖关系，使得每当一个对象发生变化，其他依赖它的对象都会得到通知并自动更新。

观察者模式又叫发布-订阅模式，在Android中用的还是比较多的，推荐理解掌握。

###### 一般模式

```
public class MyClass {
    public static void main(String [] args) {
        // 创建被观察者
        Subject subject = new ConcreteSubject();
        // 添加观察者
        subject.add(new ConcreteObserver("徐晓路"));
        subject.add(new ConcreteObserver("小埋"));
        // 更新信息
        subject.notify("博客系统更新了");

    }
}
// 观察者接口
interface Observer {
    public void update(String message);
}
// 具体观察者
class ConcreteObserver implements Observer {
    private String name = "";

    public ConcreteObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(this.name +"-"+ message);
    }
}

// 抽象被观察者
interface Subject {
    /*
    * 增加观察者
    * */
     void add(Observer ob);
    /*
    * 删除观察者
    * */
    void remove(Observer ob);
    /*
    * 更新信息
    * */
    void notify(String message);
}
class ConcreteSubject implements Subject {
    private List<Observer> list = new ArrayList<>();
    @Override
    public void add(Observer ob) {
        list.add(ob);
    }

    @Override
    public void remove(Observer ob) {
        list.remove(ob);
    }

    @Override
    public void notify(String message) {
        for (Observer observer : list) {
            observer.update(message);
        }
    }
}
复制代码
```

- Observer：抽象观察者，提供一个接口，在得到通知时更新自己。
- ConcreteObserver: 具体观察者，实现抽象观察者，在得到通知时更新自己的状态
- Subject: 抽象被观察者，将所有的观察者存储在一个集合里，并提供增加、删除观察者的接口
- ConcreteSubject: 具体被观察者，实现抽象被观察者接口，得以在更新时通知所有观察者。

###### 观察者模式的优点

- 观察者和被观察者之间是抽象耦合，变换互不影响
- 一套触发机制

###### 观察者模式的缺点

- 观察者模式是，一个被观察者，多个观察者，一旦 一个观察者卡顿，就会影响其他观察者。

###### 适用场景

- 关联行为场景，关联行为是可拆分的，而不是“组合”关系
- 事件多出发场景
- 跨系统的消息交换，如 消息队列

观察者模式在Android源码中使用还是蛮多的，比如`OnClickListener`、`ContentObserver`、`android.database.Observable`,第三方组件像`RxJava`、 `RxAndroid`、`EventBus`都用到了观察者模式，这里就不过多分析了。

##### 2.策略模式

`定义`：定义一组算法，把每一个算法封装起来，并且使它们之间可以相互切换。

###### 一般模式

```
public class MyClass {
    public static void main(String [] args) {
        Context context = new Context(new ConcreteStrategy());
        context.method();
    }
}
interface Strategy {
    public void method();
}

class ConcreteStrategy implements Strategy {

    @Override
    public void method() {
        System.out.println("this is first method");
    }
}
class ConcreteStrategy2 implements Strategy {

    @Override
    public void method() {
        System.out.println("this is second method");
    }
}
class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    public void method () {
        this.strategy.method();
    }
}
复制代码
```

- Strategy: 抽象策略角色，提供一个接口，定义所有策略要实现的方法和属性
- ConcreteStrategy：具体策略角色，实现Strategy，是想具体的方法
- Context 封装角色，屏蔽高层模块策略，算法的直接访问。

###### 优点

- 可以动态的改变对象的行为，扩展性良好。

###### 缺点

- 策略类数量多
- 所有策略必须可知

###### 适用场景

- 算法需要自由切换的场景
- 需要屏蔽算法规则的场景
- 多个类只在行为或算法上稍有不懂的场景

##### 3.访问者模式

`定义`：封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。

###### 一般模式

```
public class MyClass {
    public static void main(String [] args) {
        List<Element> list = ObjectStruture.createElement();
        for (Element element: list) {
            element.accept(new ConcreteVisitor());
        }
    }
}
// 抽象元素类
abstract class Element {
    public abstract void accept(Visitor visitor);
    public abstract void doSomething();
}
// 抽象访问者
interface Visitor {
    public void visit(ConcreteElement1 element1);
    public void visit(ConcreteElement2 element2);
}
class ConcreteElement1 extends Element {

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    @Override
    public void doSomething() {
        System.out.println("this is first element");
    }
}
class ConcreteElement2 extends Element {

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    @Override
    public void doSomething() {
        System.out.println("this is second element");
    }
}
class ConcreteVisitor implements Visitor {

    @Override
    public void visit(ConcreteElement1 element1) {
        element1.doSomething();
    }

    @Override
    public void visit(ConcreteElement2 element2) {
        element2.doSomething();
    }
}
class ObjectStruture {
    public static List<Element> createElement () {
        List<Element> list = new ArrayList<>();
        Random random = new Random();
        for (int i = 0;i< 5; i++) {
            int j = random.nextInt(50);
            if (j > 25) {
                list.add(new ConcreteElement1());
            } else {
                list.add(new ConcreteElement2());
            }
        }
        return  list;
    }
}
复制代码
```

- Element：抽象元素类，一般提供两类方法，一种是自身的业务逻辑，另外就是允许接收哪类访问者来访问
- Visitor：抽象访问者，抽象类或者接口，声明访问哪些元素
- ConcreteElement: 访问者，实现抽象访问者所声明的方法
- ConcreteVistor:元素类，是想抽象元素的所声明的accpect方法。

###### 优点

- 符合单一职责原则
- 扩展性良好，灵活度高

###### 缺点

- 具体元素变更比较困难
- 违背了依赖倒置原则

###### 适用场景

- 一个对象中存在着一些与本对象不相干的操作，为了避免这些操作污染这个对象。可以使用访问者模式
- 一组对象中，寻在这相似的操作，为了避免大量重复代码，可以使用访问者模式

##### 4.中介者模式

**定义**：用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互交互，从而使期耦合松散，并且可以独立地改变它们之间的交互。

中介者模式其实就是将网状的用户关系模型改编成星形的用户关系模型。

###### 一般模式

```
public class MyClass {
    public static void main(String [] args) {
        ConcreteColleagueA coA = new ConcreteColleagueA();
        ConcreteColleagueB coB = new ConcreteColleagueB();
                Mediator mediator = new ConcreteMediator(coA, coB);
        coA.setNumber(1000, mediator);
        System.out.println("----coA--" + coA.getNumber());
        System.out.println("----coB--"+ coB.getNumber());
        coB.setNumber(1000, mediator);
        System.out.println("----coA--" + coA.getNumber());
        System.out.println("----coB--"+ coB.getNumber());
    }
}
abstract class Colleague {
    protected int number = 0;

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }
        abstract public void setNumber(int number, Mediator mediator);
}
class ConcreteColleagueA extends Colleague {

    @Override
    public void setNumber(int number, Mediator mediator) {
        this.number = number;
        mediator.AaffectB();
    }
}
class ConcreteColleagueB extends Colleague {

    @Override
    public void setNumber(int number, Mediator mediator) {
        this.number = number;
        mediator.BaffectA();
    }
}
abstract class Mediator {
    protected ConcreteColleagueA coA;
    protected ConcreteColleagueB coB;

    public Mediator(ConcreteColleagueA coA, ConcreteColleagueB coB) {
        this.coA = coA;
        this.coB = coB;
    }
    public abstract void AaffectB();
    public abstract void BaffectA();
}

class ConcreteMediator extends Mediator {

    public ConcreteMediator(ConcreteColleagueA coA, ConcreteColleagueB coB) {
        super(coA, coB);
    }

    @Override
    public void AaffectB() {
        int number = coA.getNumber();
        coB.setNumber(number * 100);
    }

    @Override
    public void BaffectA() {
        int number = coB.getNumber();
        coA.setNumber(number * 2);
    }
}
复制代码
```

- Colleague: 同事类，提供一个方法，使得其属性的变化和中介者相关联
- Mediator: 抽象中介者，定义统一的接口，用于各同事直接通信
- ConcreteMediator: 通过协调各同事实现协同行为，因此必须依赖各个同事角色。
- Colleague: 同事类，提供一个方法，使得其属性的变化和中介者相关联
- Mediator: 抽象中介者，定义统一的接口，用于各同事直接通信
- ConcreteMediator: 通过协调各同事实现协同行为，因此必须依赖各个同事角色。

##### 5.状态模式

**定义**：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。

###### 一般模式

```
public class MyClass {
    public static void main(String [] args) {
        Context context = new Context();
        context.setState(new ConcreteState1());
        context.method2();
    }
}
abstract class State {
    protected Context context;

    public void setContext(Context context) {
        this.context = context;
    }

    public abstract void method1();
    public abstract void method2();
}
class Context {
    private State currState;

    protected static final ConcreteState1 state1 = new ConcreteState1();
    protected static final ConcreteState2 state2 = new ConcreteState2();
    public void setState(State state) {
        this.currState = state;
        this.currState.setContext(this);
    }
    public void method1() {
        this.currState.method1();
    }
    public void method2() {
        this.currState.method2();
    }
}

class ConcreteState1 extends State {

    @Override
    public void method1() {
        System.out.println("this is first method");
    }

    @Override
    public void method2() {
        super.context.setState(Context.state2);
        super.context.method2();
    }
}

class ConcreteState2 extends State {

    @Override
    public void method1() {
        super.context.setState(Context.state1);
        super.context.method1();
    }

    @Override
    public void method2() {
        System.out.println("this is second method");
    }
}
复制代码
```

- State: 抽象状态类，负责对象状态定义，并且封装环境角色以实现状态切换。
- ConcreteState：具体状态角色，完成本状态下要做的事情以及如何过渡到其他状态
- Context：环境角色，负责具体的状态切换

###### 优点

- 结构清晰，封装性好

###### 缺点

- 环境类中角色自类太多，不好管理

###### 适用场景

- 行为随状态改变而改变的场景
- 条件、分支判断语句的替代者

##### 6.备忘录模式

**定义**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

###### 一般模式

```
public class MyClass {
    public static void main(String [] args) {
        Originator originator = new Originator();
        Caretaker caretaker = new Caretaker();
        originator.setState(" 你好吗");
        caretaker.setMemento(originator.createMemento());
        // 改变状态
        originator.setState("你还好吗");
        // 回复原来状态
        originator.restoreMementor(caretaker.getMemento());
        System.out.println(originator.getState());
    }
}
/*
* 备忘录角色
* 备份、存储原有数据
* */
class Memento {
    private String state = "";

    public Memento(String state) {
        this.state = state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}
/*
*  备忘录发起类
*  备忘录中存储的就是该类的内容
* */
class Originator {
    private String state = "";

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
    public Memento createMemento() {
        return new Memento(this.state);
    }
    public void  restoreMementor(Memento memento) {
        this.setState(memento.getState());
    }
}
/*
*  备忘录管理类
*  对备忘录进行管理，存储
* */
class Caretaker {
    private Memento memento;

    public Memento getMemento() {
        return memento;
    }

    public void setMemento(Memento memento) {
        this.memento = memento;
    }
}
复制代码
```

###### 多状态多备份备忘录

通常情况下，Originator类一般是一个JavaBean，而需要保存的状态不止一个，需要备份数量也不止一个，这就是所谓的多状态多备份备忘录，就像下面代码：

```
public class MyClass {
   public static void main(String [] args) {
       Originator originator = new Originator();
       Caretaker caretaker = new Caretaker();
       originator.setState1("我是谁");
       originator.setState2("我在哪");
       originator.setState3("我在干嘛");
       caretaker.setMemento("01", originator.createMemento());
       originator.setState1("hahhaha");
       originator.setState2(" 我在家");
       originator.setState3("ouh;");
       originator.restoreMementor(caretaker.getMemento("01"));
       System.out.println("------恢复之后的状态--" + originator);
   }
}
/*
* 备忘录角色
* 备份、存储原有数据
* */
class Memento {
   private Map<String, Object> stateMap;

   public Memento(Map<String, Object> stateMap) {
       this.stateMap = stateMap;
   }

   public Map<String, Object> getStateMap() {
       return stateMap;
   }

   public void setStateMap(Map<String, Object> stateMap) {
       this.stateMap = stateMap;
   }
}
class BeanUtils {
   public static Map<String, Object> backupProp(Object bean) {
       Map<String, Object> result = new HashMap<>();
       try {
           BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass());
           //返回PropertyDescriptor类型的javaBean描述
           PropertyDescriptor[] descriptors = (PropertyDescriptor[]) beanInfo.getPropertyDescriptors();
           for (PropertyDescriptor des : descriptors) {
               String fieldName = des.getName();
               // 读取属性的方法
               Method method = des.getReadMethod();
               // 读取属性值
               Object fieldValue = method.invoke(bean, new Object[]{});
               if (!fieldName.equalsIgnoreCase("class")) {
                   result.put(fieldName, fieldValue);
               }
           }
       } catch (Exception e) {
           e.printStackTrace();
       }
       return result;
   }

   public static void restoreProp(Object bean, Map<String, Object> propMap) {
       try {
           BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass());
           //获取PropertyDescriptor的对象数组
           PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();
           //增强for循环，遍历所有的属性，设置到bean中
           for(PropertyDescriptor des: descriptors){
               //获取key值对象
               String fieldName = des.getName();
               if(propMap.containsKey(fieldName)){
                   Method setter = des.getWriteMethod();
                   setter.invoke(bean, new Object[]{propMap.get(fieldName)});
               }
           }
       } catch (Exception e) {
           e.printStackTrace();
       }
   }
}
/*
*  备忘录发起类
*  备忘录中存储的就是该类的内容
* */
class Originator {
   private String state1 = "";
   private String state2 = "";
   private String state3 = "";

   public String getState1() {
       return state1;
   }

   public String getState2() {
       return state2;
   }

   public String getState3() {
       return state3;
   }

   public void setState1(String state1) {
       this.state1 = state1;
   }

   public void setState2(String state2) {
       this.state2 = state2;
   }

   public void setState3(String state3) {
       this.state3 = state3;
   }

   public Memento createMemento() {
       return new Memento(BeanUtils.backupProp(this));
   }
   public void  restoreMementor(Memento memento) {
       BeanUtils.restoreProp(this, memento.getStateMap());
   }

   @Override
   public String toString() {
       return "Originator{" +
               "state1='" + state1 + '\'' +
               ", state2='" + state2 + '\'' +
               ", state3='" + state3 + '\'' +
               '}';
   }
}
/*
*  备忘录管理类
*  对备忘录进行管理，存储
* */
class Caretaker {
   private Map<String, Memento>  map = new HashMap<String, Memento>();
   public Memento getMemento(String index){
       return map.get(index);
   }

   public void setMemento(String index, Memento memento){
       this.map.put(index, memento);
   }
}
复制代码
```

###### 优点

- 可以回滚操作
- 发起人不用分别对每个备份状态进行管理

###### 缺点

- 对资源的消耗比较大

###### 适用场景

- 在需要回滚操作的情况下

##### 7.责任链模式

**定义**：使多个对象都有机会处理请求，从而避免了发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理该请求为止。

举个例子：比如我们去部门去办理某项手续，你去的地方不能办理，他会转交给下个部门，如果下个部门也不能办理的话，还会转交给其他部门，直到给能办理的部门。

###### 一般模式

```
public class MyClass {
    public static void main(String [] args) {
        Handler handler1 = new ConcreteHandler();
        Handler handler2 = new ConcreteHandler();
        handler1.setSuccessor(handler2);
        handler1.handleRequest();
    }
}

abstract class Handler {
    protected Handler successor;

    public Handler getSuccessor() {
        return successor;
    }

    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }
    public abstract void handleRequest();
}

class ConcreteHandler extends Handler {

    @Override
    public void handleRequest() {
        if (getSuccessor() != null) {
            getSuccessor().handleRequest();
        } else {
            System.out.println("我来处理");
        }
    }
}
复制代码
```

- 抽象处理者角色(Handler)：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。
- 具体处理者角色(ConcreteHandler)：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。

###### 优点

- 灵活度高，两者解耦

###### 缺点

- 调试不方便

##### 8.模版方法模式

**定义**：定义一个操作中的算法框架，而将一些步骤延迟到子类中，子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

举个例子：比如我们去银行取办理业务，一般的流程是取号，然后办理业务，然后给办理员做出评价。取号和评价都是基本要做的，但是其中的办理业务就会出现各种不同。

```
public class MyClass {
    public static void main(String [] args) {
        AbstractBank b1 = new ConcreteDeposit();
        b1.process();
        AbstractBank b2 = new ConcreteTrancfer();
        b2.process();
    }
}
abstract class AbstractBank {
    public void takeNumber() {
        System.out.println("取号");
    }
    public void evaluateHook () {
        System.out.println("评价操作员");
    }
    public abstract void transact();
    public void process (){
        this.takeNumber();
        this.transact();
        this.evaluateHook();
    }
}
class ConcreteDeposit extends AbstractBank {

    @Override
    public void transact() {
        System.out.println("存款");
    }
}
class ConcreteTrancfer extends AbstractBank {

    @Override
    public void transact() {
        System.out.println("转账");
    }
}
复制代码
```

###### 优点

- 形式定义算法，具体细节由子类实现
- 代码复用

###### 适用场景

- 多个子类有共有的方法，并且逻辑基本相同
- 重复复杂的算法，可以把核心算法设计为模版方法，具体细节由子类去实现
- 控制子类扩展

##### 9.迭代器模式

**定义**：提供一种方法访问一个容器对象中各个元素，而不是暴露该对象的内容细节。

###### 一般模式

```
public class MyClass {
    public static void main(String [] args) {
        Aggregate aggregate = new ConcreteAggregate();
        aggregate.add("王二");
        aggregate.add("李五");
        aggregate.add("赵四");
        Iterator iterator = aggregate.iterator();
        while (iterator.hasNext()) {
            String object = (String) iterator.next();
            System.out.println(object);
        }
    }
}

interface Iterator {
    public Object next();
    public boolean hasNext();
}

class ConcreteIterator implements Iterator {
    private List list = new ArrayList();
    private int cursor = 0;
    public ConcreteIterator(List list) {
        this.list = list;
    }

    @Override
    public Object next() {
        Object object = null;
        if (hasNext()) {
            object = list.get(cursor ++);
        }
        return object;
    }

    @Override
    public boolean hasNext() {
        if (list.size() == cursor) {
            return false;
        }
        return true;
    }
}

interface Aggregate {
    public void add(Object object);
    public void remove(Object object);
    public Iterator iterator();
}

class ConcreteAggregate implements Aggregate {
    private List list = new ArrayList();

    @Override
    public void add(Object object) {
        list.add(object);
    }

    @Override
    public void remove(Object object) {
        list.remove(object);
    }

    @Override
    public Iterator iterator() {
        return new ConcreteIterator(list);
    }
}
复制代码
```

- Iterator: 抽象迭代器，定义遍历元素所需要的方法，
- ConcreteIterator:迭代器的实现类，实现定义的方法，完成集合的迭代。
- Aggregate：抽象容器，提供iterator（）方法。
- ConcreteAggregate: 抽象容器实现类。

###### 优点

- 简化遍历方式
- 封装性良好

###### 缺点

- 对于简单的遍历，可能使用起来会比较繁琐。

##### 10.命令模式

**定义**： 将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或记录请求日志，可以提供命令的撤销和恢复功能。

###### 一般模式

```
public class MyClass {
    public static void main(String [] args) {
        Invoker invoker = new Invoker(new ConcreteCommand(new ConcreteReceiver()));
        invoker.action();
    }
}
/*
*   接收者，真正执行命令的对象
* */
abstract class Receiver {
    public abstract void method();
}
class ConcreteReceiver extends Receiver {

    @Override
    public void method() {
        System.out.println("this is a method");
    }
}
/*
*  定义命令的接口。声明执行的方法
* */
interface Command {
    public void execute();
}
class ConcreteCommand implements Command {
    private Receiver receiver ;

    public ConcreteCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        this.receiver.method();
    }
}
/*
*  要求命令执行请求，持有命令对象
* */
class Invoker {
    private Command command;

    public Invoker(Command command) {
        this.command = command;
    }
    public void action() {
        this.command.execute();
    }
}
复制代码
```

命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的职责分隔开。

##### 11.解释器模式

**定义**：给定一个语言，定义它的文法的一种表示，并表示一个解释器，这个解释器使用该表示来解释语言中的句子。

解释器模式，在Android中用到的不多，但是也可以简单了解一下。 举一个加减乘除的例子

```
public class MyClass {
    public static void main(String [] args) {
        Expression ex ;

        Context con ;
        con = new Context();

        //设置变量、常量

        Variable a = new Variable();

        Variable b = new Variable();

        Constant c = new Constant(4);

//为变量赋值

        con.addValue(a , 8);

        con.addValue(b , 9);

//运算，对句子的结构由我们自己来分析，构造

        ex = new Division(new Multiply(a , b), new Add(new Subtract(a , b) , c));

        System.out.println("运算结果为："+ex.interpret(con));
    }
}

class Context

{

    private Map valueMap = new HashMap();

    public void addValue(Variable x , int y)

    {

        Integer yi = new Integer(y);

        valueMap.put(x , yi);

    }

    public int LookupValue(Variable x)

    {

        int i = ((Integer)valueMap.get(x)).intValue();

        return i ;

    }

}

abstract class Expression {
    public abstract int interpret(Context con);
}
//终结符表达式角色

class Constant extends Expression

{

    private int i ;

    public Constant(int i)

    {
        this.i = i;
    }

    public int interpret(Context con)

    {
        return i ;
    }

}
class Variable extends Expression

{

    public int interpret(Context con)

    {
        //this为调用interpret方法的Variable对象

        return con.LookupValue(this);

    }

}
//非终结符表达式角色

class Add extends Expression

{

    private Expression left ,right ;

    public Add(Expression left , Expression right)

    {

        this.left = left ;

        this.right= right ;

    }

    public int interpret(Context con)

    {

        return left.interpret(con) + right.interpret(con);

    }

}
class Subtract extends Expression

{

    private Expression left , right ;

    public Subtract(Expression left , Expression right)

    {

        this.left = left ;

        this.right= right ;

    }

    public int interpret(Context con)

    {

        return left.interpret(con) - right.interpret(con);

    }

}
class Multiply extends Expression

{

    private Expression left , right ;

    public Multiply(Expression left , Expression right)

    {

        this.left = left ;

        this.right= right ;

    }

    public int interpret(Context con)

    {

        return left.interpret(con) * right.interpret(con);

    }

}
class Division extends Expression

{

    private Expression left , right ;

    public Division(Expression left , Expression right)

    {
        this.left = left ;
        this.right= right ;
    }

    public int interpret(Context con)

    {
        try{
            return left.interpret(con) / right.interpret(con);

        }catch(ArithmeticException ae)

        {
            System.out.println("被除数为0！");
            return -11111;
        }

    }

}
复制代码
```

- 抽象表达式(Expression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作。
- 终结符表达式(Terminal Expression)角色：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式X=Y+Z，在里面R1和R2就是终结符，对应的解析Y和Z的解释器就是终结符表达式。
- 非终结符表达式(Nonterminal Expression)角色：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式X=Y-Z中，“-"就是非终结符，解析“+”的解释器就是一个非终结符表达式。
- 环境(Context)角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如X=Y+Z，我们给Y赋值2，给Y赋值3。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了

#### 二、总结

设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。在Android的源码中也会经常会出现设计模式的影子，在这里我把所有的设计模式都简单的一一介绍了，并没有深入的去探究，有需要或者有兴趣的可以自己去深入研究一下，者对我们来说也是有益无害的



**1. 请列举出在JDK中几个常用的设计模式？**

- 单例模式：保证被创建一次，节省系统开销。
- 工厂模式（简单工厂、抽象工厂）：解耦代码。
- 观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。
- 外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。
- 模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。
- 状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
- 装饰器设计模式：（Decorator design pattern）被用于多个 Java IO 类中。

**2. 什么是设计模式？你是否在你的代码里面使用过任何设计模式？**

设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法。设计模式是代码可用性的延伸

**3. Java 中什么叫单例设计模式？请用Java 写出线程安全的单例模式**

单例模式重点在于在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个特定类实例，它被所有组件共同使用。`Java.lang.Runtime`是单例模式的经典例子。从 Java 5 开始你可以使用枚举（enum）来实现线程安全的单例。

**4. 在 Java 中，什么叫观察者设计模式（observer design pattern）**？

观察者模式是基于对象的状态变化和观察者的通讯，以便他们作出相应的操作。简单的例子就是一个天气系统，当天气变化时必须在展示给公众的视图中进行反映。这个视图对象是一个主体，而不同的视图是观察者。

**5. 使用工厂模式最主要的好处是什么？在哪里使用？**

工厂模式的最大好处是增加了创建对象时的封装层次。如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。

**6. 举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？**

装饰模式增加强了单个对象的能力。Java IO 到处都使用了装饰模式，典型例子就是 Buffered 系列类如`BufferedReader`和`BufferedWriter`，它们增强了`Reader`和`Writer`对象，以实现提升性能的 Buffer 层次的读取和写入。

**7. Java 编程为什么不允许从静态方法中访问非静态变量？**

Java 中不能从静态上下文访问非静态数据只是因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联。

**8. 如果需要设计一个 ATM 机，你的设计思路是什么？**

比如设计金融系统来说，必须知道它们应该在任何情况下都能够正常工作。不管是断电还是其他情况，ATM 应该保持**正确的状态（事务）** , 想想 **加锁（locking）、事务（transaction）、错误条件（error condition）、边界条件（boundary condition）** 等等。尽管你不能想到具体的设计，但如果你可以指出非功能性需求，提出一些问题，想到关于边界条件，这些都会是很好的。

**9. 在 Java语言 中，什么时候用重载，什么时候用重写？**

如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding），而重载（overloading）是用不同的输入做同一件事。在 Java 中，重载的方法签名不同，而重写并不是。

**10. 请举例说明什么情况下会更倾向于使用抽象类而不是接口？**

接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：

- 在 Java 中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。
- 接口通常被用来表示附属描述或行为如：`Runnable、Clonable、Serializable`等等，因此当你使用抽象类来表示行为时，你的类就不能同时是`Runnable`和`Clonable`(注：这里的意思是指如果把`Runnable`等实现为抽象类的情况)，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。
- 在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。
- 如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。

**11. 简单工厂和抽象工厂有什么区别？**

- 简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。
- 工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。
- 抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。
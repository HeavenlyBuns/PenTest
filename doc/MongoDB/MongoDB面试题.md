- ### 1.什么是MongoDB

  MongoDB是一个文档数据库，提供好的性能，领先的非关系型数据库。采用BSON存储文档数据。
  BSON（）是一种类json的一种二进制形式的存储格式，简称Binary JSON.
  相对于json多了date类型和二进制数组。

  ### 2.MongoDB的优势有哪些

  - 面向文档的存储：以 JSON 格式的文档保存数据。
  - 任何属性都可以建立索引。
  - 复制以及高可扩展性。
  - 自动分片。
  - 丰富的查询功能。
  - 快速的即时更新。

  ### 3 什么是数据库

  　　数据库可以看成是一个电子化的文件柜,用户可以对文件中的数据运行新增、检索、更新、删除等操作。数据库是一个
  所有集合的容器，在文件系统中每一个数据库都有一个相关的物理文件。

  ### 4.什么是集合(表)

  集合就是一组 MongoDB 文档。它相当于关系型数据库（RDBMS）中的表这种概念。集合位于单独的一个数据库中。
  一个集合内的多个文档可以有多个不同的字段。一般来说，集合中的文档都有着相同或相关的目的。

  ### 5 什么是文档(记录)

  　　文档由一组key value组成。文档是动态模式,这意味着同一集合里的文档不需要有相同的字段和结构。在关系型
  数据库中table中的每一条记录相当于MongoDB中的一个文

  ### 6 MongoDB和关系型数据库术语对比图

  

  ![img](F:\PROJECT\myGit\image\images\v2-4cb3078a802ff118ae39b901e101e754_720w.jpg)

  

  ### 7.什么是非关系型数据库

  　　非关系型数据库的显著特点是不使用SQL作为查询语言，数据存储不需要特定的表格模式。

  ### 8 为什么用MOngoDB？

  - 架构简单
  - 没有复杂的连接
  - 深度查询能力,MongoDB支持动态查询。
  - 容易调试
  - 容易扩展
  - 不需要转化/映射应用对象到数据库对象
  - 使用内部内存作为存储工作区,以便更快的存取数据。

  ### 9 在哪些场景使用MongoDB

  - 大数据
  - 内容管理系统
  - 移动端Apps
  - 数据管理

  ### 10 MongoDB中的命名空间是什么意思?

  mongodb存储bson对象在丛集(collection)中.数据库名字和丛集名字以句点连结起来叫做名字空间(namespace). 　　一个集合命名空间又有多个数据域(extent)，集合命名空间里存储着集合的元数据，比如集合名称，集合的
  第一个数据域和最后一个数据域的位置等等。而一个数据域由若干条文档(document)组成，每个数据域都有一个
  头部，记录着第一条文档和最后一条文档的为知，以及该数据域的一些元数据。extent之间，document之间通过
  双向链表连接。 索引的存储数据结构是B树，索引命名空间存储着对B树的根节点的指针。

  ### 11 monogodb 中的分片什么意思

  　　分片是将数据水平切分到不同的物理节点。当应用数据越来越大的时候，数据量也会越来越大。当数据量增长
  时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。利用分片技术可以添加更多的机器来应对数据量增加
  以及读写操作的要求。

  ### 12 为什么要在MongoDB中使用分析器

  　　mongodb中包括了一个可以显示数据库中每个操作性能特点的数据库分析器.通过这个分析器你可以找到比预期慢
  的查询(或写操作);利用这一信息,比如,可以确定是否需要添加索引.

  ### 13 .MongoDB支持主键外键关系吗

  　　默认MongoDB不支持主键和外键关系。 用Mongodb本身的API需要硬编码才能实现外键关联，不够直观且难度
  较大

  ### 14 MongoDB支持哪些数据类型

  - - String
    - Integer
    - Double
    - Boolean
    - Object
    - Object ID
    - Arrays
    - Min/Max Keys
    - Datetime
    - Code
    - Regular Expression等

  ### 15 为什么要在MongoDB中用"Code"数据类型

  "Code"类型用于在文档中存储 JavaScript 代码。

  ### 16 为什么要在MongoDB中用"Regular Expression"数据类型

  "Regular Expression"类型用于在文档中存储正则表达式

  ### 17 为什么在MongoDB中使用"Object ID"数据类型

  "ObjectID"数据类型用于存储文档id

  ### 18"ObjectID"有哪些部分组成

  一共有四部分组成:时间戳、客户端ID、客户进程ID、三个字节的增量计数器

  ### 19 在MongoDb中什么是索引

  索引用于高效的执行查询,没有索引的MongoDB将扫描整个集合中的所有文档,这种扫描效率很低,需要处理大量
  的数据. 索引是一种特殊的数据结构,将一小块数据集合保存为容易遍历的形式.索引能够存储某种特殊字段或字段集的
  值,并按照索引指定的方式将字段值进行排序.

  ### 20 如何添加索引

  使用db.collection.createIndex()在集合中创建一个索引

  ### 21.如何查询集合中的文档

  db.collectionName.find({key:value})

  ### 22用什么方法可以格式化输出结果

  db.collectionName.find().pretty()

  ### 23 如何使用"AND"或"OR"条件循环查询集合中的文档

  db.mycol.find( { $or: [ {key1: value1}, {key2:value2} ] } ).pretty()

  ### 24 更新数据

  db.collectionName.update({key:value},{$set:{newkey:newValue}})

  ### 25 如何删除文档

  db.collectionName.remove({key:value})

  ### 26 在MongoDB中如何排序

  并使用 1 和 -1 来指定排序方式，其中 1 表示升序，而 -1 表示降序。

  db.connectionName.find({key:value}).sort({columnName:1})

  ### 27 什么是聚合

  　　聚合操作能够处理数据记录并返回计算结果。聚合操作能将多个文档中的值组合起来，对成组数据执行各种操作，返回单一的结果。它相当于 SQL 中的 count(*) 组合 group by。对于 MongoDB 中的聚合操作，应该使用`aggregate()`方法。

  db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)

  ### 28 在MongoDB中什么是副本集（避免单点故障）

  在MongoDB中副本集由一组MongoDB实例组成，包括一个主节点多个次节点，MongoDB客户端的所有数据都
  写入主节点(Primary),副节点从主节点同步写入数据，以保持所有复制集内存储相同的数据，提高数据可用性。

  ### 29 什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？

  　NoSQL是非关系型数据库，NoSQL = Not Only SQL。
  关系型数据库采用的结构化的数据，NoSQL采用的是键值对的方式存储数据。 在处理非结构化/半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑
  使用NoSQL数据库。 在考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。

  ### 30 MongoDB支持存储过程吗？如果支持的话，怎么用？

  MongoDB支持存储过程，它是javascript写的，保存在db.system.js表中。

  ### 31如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？

  　　GridFS是一种将大型文件存储在MongoDB中的文件规范。使用GridFS可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了BSON对象有限制的问题。

  ### 32 为什么MongoDB的数据文件很大？

  　　MongoDB采用的预分配空间的方式来防止文件碎片。

  ### 33 当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？

  　　更新操作会立即发生在旧的块（Chunk）上，然后更改才会在所有权转移前复制到新的分片上。

  ### 34 MongoDB在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？

  　　不会，只会在A:{B,C}上使用索引。

  ### 35 mongodb成为最好nosql数据库的原因是什么?

  　　面向文件的 高性能 高可用性 易扩展性 丰富的查询语言

  ### 36 如果用户移除对象的属性,该属性是否从存储层中删除?

  　　是的,用户移除属性然后对象会重新保存(re-save()).

  ### 37 允许空值null吗?

  　　对于对象成员而言,是的.然而用户不能够添加空值(null)到数据库丛集(collection)因为空值不是对象.然而用户能够添加空对象{}.

  ### 38 更新操作立刻fsync到磁盘?

  　　不会,磁盘写操作默认是延迟执行的.写操作可能在两三秒(默认在60秒内)后到达磁盘.例如,如果一秒内数据库收到一千个对一个对象递增的操作,仅刷新磁盘一次.

  ### 39 如何执行事务/加锁?

  　　mongodb没有使用传统的锁或者复杂的带回滚的事务,因为它设计的宗旨是轻量,快速以及可预计的高性能.可以把它类比成mysql mylsam的自动提交模式.通过精简对事务的支持,性能得到了提升,特别是在一个可能会穿过多个服务器的系统里.

  ### 40 启用备份故障恢复需要多久?

  　　从备份数据库声明主数据库宕机到选出一个备份数据库作为新的主数据库将花费10到30秒时间.这期间在主数据库上的操作将会失败–包括写入和强一致性读取(strong consistent read)操作.然而,你还能在第二数据库上执行最终一致性查询(eventually consistent query)(在slaveok模式下),即使在这段时间里.

  ### 41 什么是master或primary?

  　　它是当前备份集群(replica set)中负责处理所有写入操作的主要节点/成员.在一个备份集群中,当失效备援(failover)事件发生时,一个另外的成员会变成primary.

  ### 42 我应该启动一个集群分片(sharded)还是一个非集群分片的 mongodb 环境?

  　　(数据量大用集群分片,数据量小用非集群)

  　　为开发便捷起见,我们建议以非集群分片(unsharded)方式开始一个 mongodb 环境,除非一台服务器不足以存放你的初始数据集.从非集群分片升级到集群分片(sharding)是无缝的,所以在你的数据集还不是很大的时候没必要考虑集群分片(sharding).

  ### 43 分片(sharding)和复制(replication)是怎样工作的?

  　　每一个分片(shard)是一个分区数据的逻辑集合.分片可能由单一服务器或者集群组成,我们推荐为每一个分片(shard)使用集群.

  ### 44数据在什么时候才会扩展到多个分片(shard)里?

  　　mongodb 分片是基于区域(range)的.所以一个集合(collection)中的所有的对象都被存放到一个块(chunk)中.只有当存在多余一个块的时候,才会有多个分片获取数据的选项.现在,每个默认块的大小是 64mb,所以你需要至少 64 mb 空间才可以实施一个迁移.

  ### 45 当我试图更新一个正在被迁移的块(chunk)上的文档时会发生什么?

  　　更新操作会立即发生在旧的分片(shard)上,然后更改才会在所有权转移(ownership transfers)前复制到新的分片上.

  ### 46 如果在一个分片(shard)停止或者很慢的时候,我发起一个查询会怎样?

  　　如果一个分片(shard)停止了,除非查询设置了“partial”选项,否则查询会返回一个错误.如果一个分片(shard)响应很慢,mongodb则会等待它的响应.

  ### 47 可以把movechunk目录里的旧文件删除吗?

  　　没问题,这些文件是在分片(shard)进行均衡操作(balancing)的时候产生的临时文件.一旦这些操作已经完成,相关的临时文件也应该被删除掉.但目前清理工作是需要手动的,所以请小心地考虑再释放这些文件的空间.

  ### 48 如果块移动操作(movechunk)失败了,我需要手动清除部分转移的文档吗?

  　　不需要,移动操作是一致(consistent)并且是确定性的(deterministic);一次失败后,移动操作会不断重试;当完成后,数据只会出现在新的分片里(shard).

  ### 49 mongodb是否支持事务

  　　MongoDB 4.0的新特性——事务（Transactions）：MongoDB 是不支持事务的，因此开发者在需要用到事务的时候，不得不借用其他工具，在业务代码层面去弥补数据库的不足。

  　　事务和会话(Sessions)关联，一个会话同一时刻只能开启一个事务操作，当一个会话断开，这个会话中的事务也会结束。

 





`MongoDB`是基于分布式文件存储的数据库，由`C++`语言编写。旨在为`WEB`应用提供可扩展的高性能数据存储解决方案,且`MongodDB`是一个介于关系数据库与非关系数据库之间的产品，是非关系型数据库中功能最丰富，最像关系数据库。

  由于`MongoDB`的特性以及功能，使得其在企业使用频率很大，所以很多面试都会MongoDB的相关知识，基于网上以及自己阅读官网文档总结2019-2020年`MongoDB`的面试题。具体如下：

###  **1Q：`MongoDB`的优势有哪些？**

- 面向集合(`Collection`)和文档(`document`)的存储，以JSON格式的文档保存数据。
- 高性能，支持`Document`中嵌入`Document`减少了数据库系统上的I/O操作以及具有完整的索引支持，支持快速查询
- 高效的传统存储方式：支持二进制数据及大型对象
- 高可用性，数据复制集，MongoDB 数据库支持服务器之间的数据复制来提供自动故障转移（`automatic failover`）
- 高可扩展性，分片(`sharding`)将数据分布在多个数据中心,MongoDB支持基于分片键创建数据区域.
- 丰富的查询功能, 聚合管道(`Aggregation Pipeline`)、全文搜索(`Text Search`)以及地理空间查询(`Geospatial Queries`)
- 支持多个存储引擎,WiredTiger存储引、In-Memory存储引擎

###  **2Q：`MongoDB` 支持哪些数据类型?**

**java类似数据类型：**

| 类型       | 解析                                                         |
| :--------- | :----------------------------------------------------------- |
| `String`   | 字符串。存储数据常用的数据类型。在 `MongoDB` 中，`UTF-8` 编码的字符串才是合法的 |
| `Integer`  | 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位 |
| `Double`   | 双精度浮点值。用于存储浮点值                                 |
| `Boolean`  | 布尔值。用于存储布尔值（真/假）                              |
| `Arrays`   | 用于将数组或列表或多个值存储为一个键                         |
| `Datetime` | 记录文档修改或添加的具体时间                                 |

**MongoDB特有数据类型：**

| 类型                 | 解析                                                         |
| :------------------- | :----------------------------------------------------------- |
| `ObjectId`           | 用于存储文档 `id`,`ObjectId`是基于分布式主键的实现`MongoDB`分片也可继续使用 |
| `Min/Max Keys`       | 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比   |
| `Code`               | 用于在文档中存储 `JavaScript`代码                            |
| `Regular Expression` | 用于在文档中存储正则表达式                                   |
| `Binary Data`        | 二进制数据。用于存储二进制数据                               |
| `Null`               | 用于创建空值                                                 |
| `Object`             | 用于内嵌文档                                                 |

### **3Q：什么是集合`Collection`、文档`Document`,以及与关系型数据库术语类比。**

- 集合`Collection`位于单独的一个数据库MongoDB 文档`Document`集合，它类似关系型数据库（RDBMS）中的表`Table`。一个集合`Collection`内的多个文档`Document`可以有多个不同的字段。通常情况下，集合`Collection`中的文档`Document`有着相同含义。
- 文档`Document`由key-value构成。文档`Document`是动态模式,这说明同一集合里的文档不需要有相同的字段和结构。类似于关系型数据库中table中的每一条记录。
- 与关系型数据库术语类比

| mongodb            | 关系型数据库 |
| :----------------- | ------------ |
| Database           | Database     |
| Collection         | Table        |
| Document           | Record/Row   |
| Filed              | Column       |
| Embedded Documents | Table join   |

###  **4Q：什么是”`Mongod`“,以及`MongoDB`命令。**

  `mongod`是处理`MongoDB`系统的主要进程。它处理数据请求，管理数据存储，和执行后台管理操作。当我们运行`mongod`命令意味着正在启动`MongoDB`进程,并且在后台运行。

`MongoDB`命令：

| 命令                                    | 说明               |
| --------------------------------------- | ------------------ |
| use database_name                       | 切换数据库         |
| db.myCollection.find().pretty()         | 格式化打印结果     |
| db.getCollection(collectionName).find() | 修改Collection名称 |

###  **5Q："`Mongod`"默认参数有?**

- 传递数据库存储路径，默认是`"/data/db"`
- 端口号 默认是 "27017"

### **6Q：`MySQL`和`mongodb`的区别**

| 形式         | MongoDB                                                      | MySQL                             |
| ------------ | ------------------------------------------------------------ | --------------------------------- |
| 数据库模型   | 非关系型                                                     | 关系型                            |
| 存储方式     |                                                              | 虚拟内存+持久化                   |
| 查询语句     | 独特的MongoDB查询方式                                        | 传统SQL语句                       |
| 架构特点     | 副本集以及分片                                               | 常见单点、M-S、MHA、MMM等架构方式 |
| 数据处理方式 | 基于内存，将热数据存在物理内存中，从而达到高速读写           | 不同的引擎拥有自己的特点          |
| 使用场景     | 事件的记录，内容管理或者博客平台等数据大且非结构化数据的场景 | 适用于数据量少且很多结构化数据    |

### 7Q：问`mongodb`和`redis`区别以及选择原因

| 形式           | MongoDB                                                      | redis                                                        |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 内存管理机制   | MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘 | Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据 |
| 支持的数据结构 | MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引       | Redis 支持的数据结构丰富，包括hash、set、list等              |
| 性能           | mongodb依赖内存，TPS较高                                     | Redis依赖内存，TPS非常高。性能上Redis优于MongoDB             |
| 可靠性         | 支持持久化以及复制集增加可靠性                               | Redis依赖快照进行持久化；AOF增强可靠性；增强可靠性的同时，影响访问性能 |
| 数据分析       | mongodb内置数据分析功能（mapreduce）                         | Redis不支持                                                  |
| 事务支持情况   | 只支持单文档事务，需要复杂事务支持的场景暂时不适合           | Redis 事务支持比较弱，只能保证事务中的每个操作连续执行       |
| 集群           | MongoDB 集群技术比较成熟                                     | Redis从3.0开始支持集群                                       |

 **选择原因：**

- 架构简单
- 没有复杂的连接
- 深度查询能力,`MongoDB`支持动态查询。
- 容易调试
- 容易扩展
- 不需要转化/映射应用对象到数据库对象
- 使用内部内存作为存储工作区,以便更快的存取数据。

### **8Q：如何执行事务/加锁?**

  `mongodb`没有使用传统的锁或者复杂的带回滚的事务,因为它设计的宗旨是轻量,快速以及可预计的高性能.可以把它类比成`mysql mylsam`的自动提交模式.通过精简对事务的支持,性能得到了提升,特别是在一个可能会穿过多个服务器的系统里.

### **9Q:更新操作会立刻fsync到磁盘?**

  不会,磁盘写操作默认是延迟执行的.写操作可能在两三秒(默认在60秒内)后到达磁盘，通过 `syncPeriodSecs` 启动参数，可以进行配置.例如,如果一秒内数据库收到一千个对一个对象递增的操作,仅刷新磁盘一次.

### MongoDB索引

**10Q: 索引类型有哪些？**

- 单字段索引(`Single Field Indexes`)
- 复合索引(`Compound Indexes`)
- 多键索引(`Multikey Indexes`)
- 全文索引(`text Indexes`)
- Hash 索引(`Hash Indexes`)
- 通配符索引(`Wildcard Index`)
- 2dsphere索引(`2dsphere Indexes`)

**11Q：`MongoDB`在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？**

 由于`MongoDB`索引使用`B-tree`树原理，只会在A:{B,C}上使用索引
 

**`MongoDB`索引详情可看文章**[【**`MongoDB`系列--轻松应对面试中遇到的MongonDB索引(index)问题**】](https://juejin.im/post/5d41924f5188255d5102e1fd)，**其中包括很多索引的问题：**

- **创建索引，需要考虑的问题**
- **索引限制问题**
- **索引类型详细解析**
- **索引的种类问题**

### **12Q：什么是聚合**

  聚合操作能够处理数据记录并返回计算结果。聚合操作能将多个文档中的值组合起来，对成组数据执行各种操作，返回单一的结果。它相当于 `SQ`L 中的 `count(*)` 组合 `group by`。对于 `MongoDB` 中的聚合操作，应该使用`aggregate()`方法。

**详情可查看文章**[【**MongoDB系列--深入理解MongoDB聚合（Aggregation）**】](https://juejin.im/post/5d40482ce51d4561c41fb79e)，**其中包括很多聚合的问题：**

- **聚合管道（`aggregation pipeline`）的问题**
- **`Aggregation Pipeline` 优化等问题**
- **Map-Reduce函数的问题**

### MongoDB分片

**13Q：`monogodb` 中的分片`sharding`**

  分片`sharding`是将数据水平切分到不同的物理节点。当应用数据越来越大的时候，数据量也会越来越大。当数据量增长 时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。利用分片技术可以添加更多的机器来应对数据量增加 以及读写操作的要求。

**14Q：分片(`Shard`)和复制(`replication`)是怎样工作的?**

 每一个分片(`shard`)是一个分区数据的逻辑集合。分片可能由单一服务器或者集群组成，我们推荐为每一个分片(`shard`)使用集群。

**15Q：如果块移动操作(`moveChunk`)失败了，我需要手动清除部分转移的文档吗?**

 不需要，移动操作是一致(`consistent`)并且是确定性的(`deterministic`)。

- 一次失败后，移动操作会不断重试。
- 当完成后，数据只会出现在新的分片里(shard)

**16Q：数据在什么时候才会扩展到多个分片(`Shard`)里?**

 `MongoDB` 分片是基于区域(`range`)的。所以一个集合(`collection`)中的所有的对象都被存放到一个块(`chunk`)中,默认块的大小是 64Mb。当数据容量超过64 Mb，才有可能实施一个迁移，只有当存在不止一个块的时候，才会有多个分片获取数据的选项。

**17Q：更新一个正在被迁移的块（Chunk）上的文档时会发生什么？**

 更新操作会立即发生在旧的块（Chunk）上，然后更改才会在所有权转移前复制到新的分片上。

**18Q：如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？**

如果一个分片停止了，除非查询设置了 “`Partial`” 选项，否则查询会返回一个错误。如果一个分片响应很慢，`MongoDB` 会等待它的响应。

### MongoDB复制集

**19Q：`MongoDB`副本集实现高可用的原理**

 `MongoDB` 使用了其复制(`Replica Set`)方案，实现自动容错机制为高可用提供了基础。目前，`MongoDB` 支持两种复制模式：

- `Master` / `Slave` ，主从复制，角色包括 `Master` 和 `Slave` 。
- `Replica Set` ，复制集复制，角色包括 `Primary` 和 `Secondary` 以及 `Arbiter` 。(**生产环境必选**)

**20Q：什么是`master`或`primary`？**

 副本集只能有一个主节点能够确认写入操作来接收所有写操作，并记录其操作日志中的数据集的所有更改(记录在oplog中)。在集群中，当主节点（`master`）失效，Secondary节点会变为`master`

**21Q：什么是`Slave`或`Secondary`？**

 复制主节点的oplog并将oplog记录的操作应用于其数据集，如果主节点宕机了，将从符合条件的从节点选举选出新的主节点。

**22Q:什么是`Arbiter`？**

 仲裁节点不维护数据集。 仲裁节点的目的是通过响应其他副本集节点的心跳和选举请求来维护副本集中的仲裁

**23Q：复制集节点类型有哪些？**

- 优先级0型(`Priority 0`)节点
- 隐藏型(`Hidden`)节点
- 延迟型(`Delayed`)节点
- 投票型(`Vote`)节点以及不可投票节点

**24Q:启用备份故障恢复需要多久?**

  从备份数据库声明主数据库宕机到选出一个备份数据库作为新的主数据库将花费10到30秒时间.这期间在主数据库上的操作将会失败–包括写入和强一致性读取(`strong consistent read`)操作.然而,你还能在第二数据库上执行最终一致性查询(`eventually consistent query`)(在`slaveok`模式下),即使在这段时间里.

**`MongoDB`复制详解分析可查看文章**[【**MongoDB系列-解决面试中可能遇到的MongoDB复制集（replica set）问题**】](https://juejin.im/post/5d492ab9f265da03ad1437ed)

### 25Q：`raft`选举过程，投票规则？

**选举过程：**

  当系统启动好之后，初始选举后系统由1个`Leader`和若干个`Follower`角色组成。然后突然由于某个异常原因，`Leader`服务出现了异常，导致`Follower`角色检测到和`Leader`的上次RPC更新时间超过给定阈值时间时。此时`Followe`r会认为`Leader`服务已出现异常，然后它将会发起一次新的`Leader`选举行为，同时将自身的状态从`Follower`切换为`Candidate`身份。随后请求其它`Follower`投票选择自己。

**投票规则：**

- 当一个候选人获得了同一个任期号内的大多数选票，就成为领导人。
- 每个节点最多在一个任期内投出一张选票。并且按照先来先服务的原则。
- 一旦候选人赢得选举，立刻成为领导，并发送心跳维持权威，同时阻止新领导人的诞生

**可查看文章**[【**通俗易懂的Paxos算法-基于消息传递的一致性算法**】](https://juejin.im/post/5d122a306fb9a07ee9587e71)

### **26Q：在哪些场景使用`MongoDB`?**

**规则：** 如果业务中存在大量复杂的事务逻辑操作，则不要用`MongoDB`数据库；在处理非结构化 / 半结构化的大数据使用`MongoDB`，操作的数据类型为动态时也使用`MongoDB`，比如：

- 内容管理系统，切面数据、日志记录
- 移动端`Apps`：`O2O`送快递骑手、快递商家的信息（包含位置信息）
- 数据管理，监控数据

**1. mongodb 与mysql 的区别？**
mongodb的本质还是一个数据库产品，3.0以上版本其稳定性和健壮性有很大提升。它与mysql的区别在于它不会遵循一些约束，比如：sql标准、ACID属性，表结构等。其主要特性如下：
 面向集合文档的存储：适合存储Bson（json的扩展）形式的数据；
 格式自由，数据格式不固定，生产环境下修改结构都可以不影响程序运行；
 强大的查询语句，面向对象的查询语言，基本覆盖sql语言所有能力；
 完整的索引支持，支持查询计划；
 支持复制和自动故障转移；
 支持二进制数据及大型对象（文件）的高效存储；
 使用分片集群提升系统扩展性；
 使用内存映射存储引擎，把磁盘的IO操作转换成为内存的操作；

**2. mongoDB 主要使用在什么应用场景？**
 MongoDB 的应用已经渗透到各个领域，比如游戏、物流、电商、内容管理、社交、物联网、视频直播等，以下是几个实际的应用案例：
 游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新
 物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。
 社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能
 物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析
 视频直播，使用 MongoDB 存储用户信息、礼物信息等

**3. 怎么样做mongodb 查询优化**
 第一步 找出慢速查询
**1. 开启内置的查询分析器,记录读写操作效率:**
    db.setProfilingLevel(n,{m}),n的取值可选0,1,2；
   0是默认值表示不记录；
   1表示记录慢速操作,如果值为1,m必须赋值单位为ms,用于定义慢速查询时间的阈值；
   2表示记录所有的读写操作；
    例如:db.setProfilingLevel(1,300)
**2. 查询监控结果**
  监控结果保存在一个特殊的盖子集合system.profile里,这个集合分配了128kb的空间,要确保监控分析数据不会消耗太多的系统性资源；盖子集合维护了自然的插入顺序,可以使用$natural操作符进行排序,如:db.system.profile.find().sort({'$natural':-1}).limit(5)

 第二步 分析慢速查询
找出慢速查询的原因比较棘手,原因可能有多个:应用程序设计不合理、不正确的数据模型、硬件配置问题,缺少索引等；接下来对于缺少索引的情况进行分析:使用explain分析慢速查询
  例如:db.orders.find({'price':{'$lt':2000}}).explain('executionStats')
  explain的入参可选值为:
   "queryPlanner" 是默认值,表示仅仅展示执行计划信息；
   "executionStats" 表示展示执行计划信息同时展示被选中的执行计划的执行情况信息；
    "allPlansExecution" 表示展示执行计划信息,并展示被选中的执行计划的执行情况信息,还展示备选的执行计划的执行情况信息；

 第三步 解读explain结果 
queryPlanner（执行计划描述）
  winningPlan（被选中的执行计划）
    stage（可选项:COLLSCAN 没有走索引；IXSCAN使用了索引）
  rejectedPlans(候选的执行计划)
executionStats(执行情况描述)
  nReturned （返回的文档个数）
  executionTimeMillis（执行时间ms）
  totalKeysExamined （检查的索引键值个数）
  totalDocsExamined （检查的文档个数）

优化目标 Tips:
\1. 根据需求建立索引
\2. 每个查询都要使用索引以提高查询效率, winningPlan. stage 必须为IXSCAN ；
\3. 追求totalDocsExamined = nReturned

**4. mongodb 的索引注意事项？**
\1. 索引很有用,但是它也是有成本的——它占内存,让写入变慢；
\2. mongoDB通常在一次查询里使用一个索引,所以多个字段的查询或者排序需要复合索引才能更加高效；
\3. 复合索引的顺序非常重要
\4. 在生成环境构建索引往往开销很大,时间也不可以接受,在数据量庞大之前尽量进行查询优化和构建索引；
\5. 避免昂贵的查询,使用查询分析器记录那些开销很大的查询便于问题排查；
\6. 通过减少扫描文档数量来优化查询,使用explai对开销大的查询进行分析并优化；
\7. 索引是用来查询小范围数据的，不适合使用索引的情况：
   每次查询都需要返回大部分数据的文档，避免使用索引
   写比读多

**5. mongodb 是怎么实现高可用？**

![img](F:\PROJECT\myGit\image\images\0def6f4df5304f96f40afe51de04bc8bc46.jpg)

`MongoDB`是基于分布式文件存储的数据库，由`C++`语言编写。旨在为`WEB`应用提供可扩展的高性能数据存储解决方案,且`MongodDB`是一个介于关系数据库与非关系数据库之间的产品，是非关系型数据库中功能最丰富，最像关系数据库。

  由于`MongoDB`的特性以及功能，使得其在企业使用频率很大，所以很多面试都会MongoDB的相关知识，基于网上以及自己阅读官网文档总结2019-2020年`MongoDB`的面试题。具体如下：

###  **1Q：`MongoDB`的优势有哪些？**

- 面向集合(`Collection`)和文档(`document`)的存储，以JSON格式的文档保存数据。
- 高性能，支持`Document`中嵌入`Document`减少了数据库系统上的I/O操作以及具有完整的索引支持，支持快速查询
- 高效的传统存储方式：支持二进制数据及大型对象
- 高可用性，数据复制集，MongoDB 数据库支持服务器之间的数据复制来提供自动故障转移（`automatic failover`）
- 高可扩展性，分片(`sharding`)将数据分布在多个数据中心,MongoDB支持基于分片键创建数据区域.
- 丰富的查询功能, 聚合管道(`Aggregation Pipeline`)、全文搜索(`Text Search`)以及地理空间查询(`Geospatial Queries`)
- 支持多个存储引擎,WiredTiger存储引、In-Memory存储引擎

###  **2Q：`MongoDB` 支持哪些数据类型?**

**java类似数据类型：**

| 类型       | 解析                                                         |
| ---------- | ------------------------------------------------------------ |
| `String`   | 字符串。存储数据常用的数据类型。在 `MongoDB` 中，`UTF-8` 编码的字符串才是合法的 |
| `Integer`  | 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位 |
| `Double`   | 双精度浮点值。用于存储浮点值                                 |
| `Boolean`  | 布尔值。用于存储布尔值（真/假）                              |
| `Arrays`   | 用于将数组或列表或多个值存储为一个键                         |
| `Datetime` | 记录文档修改或添加的具体时间                                 |

**MongoDB特有数据类型：**

| 类型                 | 解析                                                         |
| -------------------- | ------------------------------------------------------------ |
| `ObjectId`           | 用于存储文档 `id`,`ObjectId`是基于分布式主键的实现`MongoDB`分片也可继续使用 |
| `Min/Max Keys`       | 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比   |
| `Code`               | 用于在文档中存储 `JavaScript`代码                            |
| `Regular Expression` | 用于在文档中存储正则表达式                                   |
| `Binary Data`        | 二进制数据。用于存储二进制数据                               |
| `Null`               | 用于创建空值                                                 |
| `Object`             | 用于内嵌文档                                                 |

### **3Q：什么是集合`Collection`、文档`Document`,以及与关系型数据库术语类比。**

- 集合`Collection`位于单独的一个数据库MongoDB 文档`Document`集合，它类似关系型数据库（RDBMS）中的表`Table`。一个集合`Collection`内的多个文档`Document`可以有多个不同的字段。通常情况下，集合`Collection`中的文档`Document`有着相同含义。
- 文档`Document`由key-value构成。文档`Document`是动态模式,这说明同一集合里的文档不需要有相同的字段和结构。类似于关系型数据库中table中的每一条记录。
- 与关系型数据库术语类比

| mongodb            | 关系型数据库 |
| ------------------ | ------------ |
| Database           | Database     |
| Collection         | Table        |
| Document           | Record/Row   |
| Filed              | Column       |
| Embedded Documents | Table join   |

###  **4Q：什么是”`Mongod`“,以及`MongoDB`命令。**

  `mongod`是处理`MongoDB`系统的主要进程。它处理数据请求，管理数据存储，和执行后台管理操作。当我们运行`mongod`命令意味着正在启动`MongoDB`进程,并且在后台运行。

`MongoDB`命令：

| 命令                                    | 说明               |
| --------------------------------------- | ------------------ |
| use database_name                       | 切换数据库         |
| db.myCollection.find().pretty()         | 格式化打印结果     |
| db.getCollection(collectionName).find() | 修改Collection名称 |

###  **5Q："`Mongod`"默认参数有?**

- 传递数据库存储路径，默认是`"/data/db"`
- 端口号 默认是 "27017"

### **6Q：`MySQL`和`mongodb`的区别**

| 形式         | MongoDB                                                      | MySQL                             |                            |
| ------------ | ------------------------------------------------------------ | --------------------------------- | -------------------------- |
| 数据库模型   | 非关系型                                                     | 关系型                            |                            |
| 存储方式     |                                                              | 虚拟内存+持久化                   | 不同的引擎有不同的存储方式 |
| 查询语句     | 独特的MongoDB查询方式                                        | 传统SQL语句                       |                            |
| 架构特点     | 副本集以及分片                                               | 常见单点、M-S、MHA、MMM等架构方式 |                            |
| 数据处理方式 | 基于内存，将热数据存在物理内存中，从而达到高速读写           | 不同的引擎拥有自己的特点          |                            |
| 使用场景     | 事件的记录，内容管理或者博客平台等数据大且非结构化数据的场景 | 适用于数据量少且很多结构化数据    |                            |

### 7Q：问`mongodb`和`redis`区别以及选择原因

| 形式           | MongoDB                                                      | redis                                                        |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 内存管理机制   | MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘 | Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据 |
| 支持的数据结构 | MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引       | Redis 支持的数据结构丰富，包括hash、set、list等              |
| 性能           | mongodb依赖内存，TPS较高                                     | Redis依赖内存，TPS非常高。性能上Redis优于MongoDB             |
| 可靠性         | 支持持久化以及复制集增加可靠性                               | Redis依赖快照进行持久化；AOF增强可靠性；增强可靠性的同时，影响访问性能 |
| 数据分析       | mongodb内置数据分析功能（mapreduce）                         | Redis不支持                                                  |
| 事务支持情况   | 只支持单文档事务，需要复杂事务支持的场景暂时不适合           | Redis 事务支持比较弱，只能保证事务中的每个操作连续执行       |
| 集群           | MongoDB 集群技术比较成熟                                     | Redis从3.0开始支持集群                                       |

 **选择原因：**

- 架构简单
- 没有复杂的连接
- 深度查询能力,`MongoDB`支持动态查询。
- 容易调试
- 容易扩展
- 不需要转化/映射应用对象到数据库对象
- 使用内部内存作为存储工作区,以便更快的存取数据。

### **8Q：如何执行事务/加锁?**

  `mongodb`没有使用传统的锁或者复杂的带回滚的事务,因为它设计的宗旨是轻量,快速以及可预计的高性能.可以把它类比成`mysql mylsam`的自动提交模式.通过精简对事务的支持,性能得到了提升,特别是在一个可能会穿过多个服务器的系统里.

### **9Q:更新操作会立刻fsync到磁盘?**

  不会,磁盘写操作默认是延迟执行的.写操作可能在两三秒(默认在60秒内)后到达磁盘，通过 `syncPeriodSecs` 启动参数，可以进行配置.例如,如果一秒内数据库收到一千个对一个对象递增的操作,仅刷新磁盘一次.

### MongoDB索引

**10Q: 索引类型有哪些？**

- 单字段索引(`Single Field Indexes`)
- 复合索引(`Compound Indexes`)
- 多键索引(`Multikey Indexes`)
- 全文索引(`text Indexes`)
- Hash 索引(`Hash Indexes`)
- 通配符索引(`Wildcard Index`)
- 2dsphere索引(`2dsphere Indexes`)

**11Q：`MongoDB`在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？**

　由于`MongoDB`索引使用`B-tree`树原理，只会在A:{B,C}上使用索引
　

**`MongoDB`索引详情可看文章**[【**`MongoDB`系列--轻松应对面试中遇到的MongonDB索引(index)问题**】](https://segmentfault.com/a/1190000020757508)，**其中包括很多索引的问题：**

- **创建索引，需要考虑的问题**
- **索引限制问题**
- **索引类型详细解析**
- **索引的种类问题**

### **12Q：什么是聚合**

  聚合操作能够处理数据记录并返回计算结果。聚合操作能将多个文档中的值组合起来，对成组数据执行各种操作，返回单一的结果。它相当于 `SQ`L 中的 `count(*)` 组合 `group by`。对于 `MongoDB` 中的聚合操作，应该使用`aggregate()`方法。

**详情可查看文章**[【**MongoDB系列--深入理解MongoDB聚合（Aggregation）**】](https://segmentfault.com/a/1190000020685264)，**其中包括很多聚合的问题：**

- **聚合管道（`aggregation pipeline`）的问题**
- **`Aggregation Pipeline` 优化等问题**
- **Map-Reduce函数的问题**

### MongoDB分片

**13Q：`monogodb` 中的分片`sharding`**

  分片`sharding`是将数据水平切分到不同的物理节点。当应用数据越来越大的时候，数据量也会越来越大。当数据量增长
时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。利用分片技术可以添加更多的机器来应对数据量增加
以及读写操作的要求。

**14Q：分片(`Shard`)和复制(`replication`)是怎样工作的?**

 每一个分片(`shard`)是一个分区数据的逻辑集合。分片可能由单一服务器或者集群组成，我们推荐为每一个分片(`shard`)使用集群。

**15Q：如果块移动操作(`moveChunk`)失败了，我需要手动清除部分转移的文档吗?**

 不需要，移动操作是一致(`consistent`)并且是确定性的(`deterministic`)。

- 一次失败后，移动操作会不断重试。
- 当完成后，数据只会出现在新的分片里(shard)

**16Q：数据在什么时候才会扩展到多个分片(`Shard`)里?**

 `MongoDB` 分片是基于区域(`range`)的。所以一个集合(`collection`)中的所有的对象都被存放到一个块(`chunk`)中,默认块的大小是 64Mb。当数据容量超过64 Mb，才有可能实施一个迁移，只有当存在不止一个块的时候，才会有多个分片获取数据的选项。

**17Q：更新一个正在被迁移的块（Chunk）上的文档时会发生什么？**

 更新操作会立即发生在旧的块（Chunk）上，然后更改才会在所有权转移前复制到新的分片上。

**18Q：如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？**

如果一个分片停止了，除非查询设置了 “`Partial`” 选项，否则查询会返回一个错误。如果一个分片响应很慢，`MongoDB` 会等待它的响应。

### MongoDB复制集

**19Q：`MongoDB`副本集实现高可用的原理**

 `MongoDB` 使用了其复制(`Replica Set`)方案，实现自动容错机制为高可用提供了基础。目前，`MongoDB` 支持两种复制模式：

- `Master` / `Slave` ，主从复制，角色包括 `Master` 和 `Slave` 。
- `Replica Set` ，复制集复制，角色包括 `Primary` 和 `Secondary` 以及 `Arbiter` 。(**生产环境必选**)

**20Q：什么是`master`或`primary`？**

 副本集只能有一个主节点能够确认写入操作来接收所有写操作，并记录其操作日志中的数据集的所有更改(记录在oplog中)。在集群中，当主节点（`master`）失效，Secondary节点会变为`master`

**21Q：什么是`Slave`或`Secondary`？**

 复制主节点的oplog并将oplog记录的操作应用于其数据集，如果主节点宕机了，将从符合条件的从节点选举选出新的主节点。

**22Q:什么是`Arbiter`？**

 仲裁节点不维护数据集。 仲裁节点的目的是通过响应其他副本集节点的心跳和选举请求来维护副本集中的仲裁

**23Q：复制集节点类型有哪些？**

- 优先级0型(`Priority 0`)节点
- 隐藏型(`Hidden`)节点
- 延迟型(`Delayed`)节点
- 投票型(`Vote`)节点以及不可投票节点

**24Q:启用备份故障恢复需要多久?**

  从备份数据库声明主数据库宕机到选出一个备份数据库作为新的主数据库将花费10到30秒时间.这期间在主数据库上的操作将会失败–包括写入和强一致性读取(`strong consistent read`)操作.然而,你还能在第二数据库上执行最终一致性查询(`eventually consistent query`)(在`slaveok`模式下),即使在这段时间里.

**`MongoDB`复制详解分析可查看文章**[【**MongoDB系列-解决面试中可能遇到的MongoDB复制集（replica set）问题**】](https://segmentfault.com/a/1190000020782847)

### 25Q：`raft`选举过程，投票规则？

**选举过程：**

  当系统启动好之后，初始选举后系统由1个`Leader`和若干个`Follower`角色组成。然后突然由于某个异常原因，`Leader`服务出现了异常，导致`Follower`角色检测到和`Leader`的上次RPC更新时间超过给定阈值时间时。此时`Followe`r会认为`Leader`服务已出现异常，然后它将会发起一次新的`Leader`选举行为，同时将自身的状态从`Follower`切换为`Candidate`身份。随后请求其它`Follower`投票选择自己。

**投票规则：**

- 当一个候选人获得了同一个任期号内的大多数选票，就成为领导人。
- 每个节点最多在一个任期内投出一张选票。并且按照先来先服务的原则。
- 一旦候选人赢得选举，立刻成为领导，并发送心跳维持权威，同时阻止新领导人的诞生

### **26Q：在哪些场景使用`MongoDB`?**

**规则：** 如果业务中存在大量复杂的事务逻辑操作，则不要用`MongoDB`数据库；在处理非结构化 / 半结构化的大数据使用`MongoDB`，操作的数据类型为动态时也使用`MongoDB`，比如：

- 内容管理系统，切面数据、日志记录
- 移动端`Apps`：`O2O`送快递骑手、快递商家的信息（包含位置信息）
- 数据管理，监控数据
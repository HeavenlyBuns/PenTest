## 一、事务

​         **一个事务会涉及大量的cpu操作和IO操作，这些操作会被打包成一个执行单元，要么同时完成，要么同时都不完成**。

​        事务是一组原子性的sql命令或者说是一个独立的工作单元，如果其中任何一条sql语句因为崩溃或者其他原因执行失败，那么该组所有的sql语句都不会执行。如果没有显示启动事务，数据库会根据autocommit的值，默认每条sql操作都会自动提交。



​         **在MySQL里，事务是在引擎层面实现，比如MyIsam不支持，InnoDB支持。**

## 二、ACID

​        **事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。**

- **原子性（ Atomicity ）**：事务的所有操作要么全部成功，要么全部回滚。
- **一致性（ Consistency ）**：事务执行的结果必须是使数据库总是从一个一致性的状态转换到另一个一致性的状态。
- **隔离性（ Isolation ）**：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。每降低一个事务的隔离级别都能提高数据库的并发，但同时不安全性就增加了。有四种隔离级别：
  - **读未提交(Read Uncommitted)**：其他事务未提交就可以读。
  - **读已提交(Read Committed)**：其他事务只有提交了才能读。
  - **可重复读(Repeatable Read)**：只管自己启动事务时候的状态，不接受其他事务的影响。
  - **串行化(Serializable)**：按照顺序提交事务保证了数据的安全性，但无法实现并发。

- **持久性（ Durability ）**：已被提交的事务对数据库的修改应该永久保存在数据库中。

## 三、隔离级别

实际上，这些场景都是出现在多个事务同时执行时的场景。



| 隔离级别                        | 脏读   | 不可重复读 | 幻读   |
| ------------------------------- | ------ | ---------- | ------ |
| 读取未提交内容(Read uncommited) | 可能   | 可能       | 可能   |
| 读取提交内容(Read commited)     | 不可能 | 可能       | 可能   |
| 可重复读(Repeatable read)       | 不可能 | 不可能     | 可能   |
| 串行化(Serializable)            | 不可能 | 不可能     | 不可能 |

#### 3.1读取未提交内容（Read Uncommitted）

​     在该隔离级别，所有事务都可以看到其他未提交事务的执行结果，导致了脏读。如果另一个事务回滚了，就会造成数据的不一致性。**Read Uncommitted是事务隔离级别中最低的**。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。**读取未提交的数据，也被称之为脏读（Dirty Read）**

**举例：**



![在这里插入图片描述](http://zhaojiaxing.gitee.io/image/images/16f7e79d463e70dc)



假设打赏的逻辑是：① 我的账户+1元；② 你的账户-1元。

当你执行到第一个步骤，我去查询我的账户已经是2元了，很开心！！！宣布请大家去撸串！！！但是最后扣款的时候发现你余额不足了，回滚了，我的1元没了，就很难受！！



#### 3.2 Read Committed（读取提交内容）

​       这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：**一个事务只能看见已经提交事务所做的改变**。这种隔离级别也支持所谓的**不可重复读（Nonrepeatable Read）**，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

**不可重复读（Nonrepeatable Read）与脏读的区别**：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但实际上是违反了事务的一致性原则。

**举例：**



![在这里插入图片描述](http://zhaojiaxing.gitee.io/image/images/16f7e79d483b4c55)



假设我查了下账户余额，看到你们给小编打赏了1块钱，很开心！！！宣布请大家去撸串！！！在付款之前，钱被另外一个人取走，又查询到没钱了，被留下来洗碗了！！！

因为我查询完后，这条数据没锁住，又被别的事务更新了，导致当前事务每次都是读到最新的数据。



#### 3.3 Repeatable Read（可重读）

​      **这是MySQL的默认事务隔离级别**，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：**幻读 （Phantom Read）**。简单的说，**幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。**InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交，这样就会导致幻读问题。

**举例：**

![在这里插入图片描述](http://zhaojiaxing.gitee.io/image/images/16f7e79d486913a0)

看到了吗，在一个事务A中，第一次查询某条记录，是没有的，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。

实际上，在InnoDB引擎中，对于索引的扫描，不仅锁住扫描到的索引，而且还锁住这些索引覆盖的范围（gap），因此这个范围是内插入数据是不允许的。

#### 3.4 Serializable（可串行化）

​      **这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题**。简言之，它是**在每个读的数据行上加上共享锁**。在这个级别，可能导致大量的超时现象和锁竞争。

这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：

- **脏读(Drity Read)**：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
- **不可重复读(Non-repeatable read)**:在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
- **幻读(Phantom Read)**:在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就有几列数据是未查询出来的，如果此时插入和另外一个事务插入的数据，就会报错。



## 四、mysql模拟事务隔离性测试

```
SELECT @@session.tx_isolation;   
SELECT @@tx_isolation;  
  
SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted;  
SET SESSION TRANSACTION ISOLATION LEVEL read committed;  
SET SESSION TRANSACTION ISOLATION LEVEL repeatable read;  
SET SESSION TRANSACTION ISOLATION LEVEL serializable;  

start transaction;

--建表
drop table AMOUNT;
CREATE TABLE `AMOUNT` (
`id`  varchar(10) NULL,
`money`  numeric NULL
)
;
--插入数据
insert into amount(id,money) values('A', 800);
insert into amount(id,money) values('B', 200);
insert into amount(id,money) values('C', 1000);
--测试可重复读，插入数据
insert into amount(id,money) values('D', 1000);

--设置事务
SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted;  
SELECT @@tx_isolation;  
--开启事务
start transaction;

--脏读演示，读到其他事务未提交的数据
--案列1，事务一：A向B转200，事务二：查看B金额变化，事务一回滚事务
update amount set money = money - 200 where id = 'A';
update amount set money = money + 200 where id = 'B';

--不可重复读演示，读到了其他事务提交的数据
--案列2，事务一：B向A转200，事务二：B向C转200转100
SET SESSION TRANSACTION ISOLATION LEVEL read committed;  

--开启事务
start transaction;
--两个事务都查一下数据(转账之前需要，查一下金额是否够满足转账)
select * from amount;
--事务一：B向A转200
update amount set money = money - 200 where id = 'B';
update amount set money = money + 200 where id = 'A';

commit;
--事务二：B向C转200转100
update amount set money = money - 100 where id = 'B';
update amount set money = money + 100 where id = 'C';
commit;
--从事务二的角度来看，读到了事务一提交事务的数据，导致金额出现负数

--幻读演示
--案列3，事务一：B向A转200，事务二：B向C转200转100
SET SESSION TRANSACTION ISOLATION LEVEL repeatable read;  

--开启事务
start transaction;
--两个事务都查一下数据(转账之前需要，查一下金额是否够满足转账)
select * from amount;
--事务一：B向A转200
update amount set money = money - 200 where id = 'B';
update amount set money = money + 200 where id = 'A';

commit;
--事务二：B向C转200转100
update amount set money = money - 100 where id = 'B';
update amount set money = money + 100 where id = 'C';
commit;
--从事务二的角度来看，读到了事务一提交事务的数据，导致金额出现负数
```



### 准备数据

准备一个账户表，表里三个字段，分别是主键id，账户名和金额

```
create table account(
	id int(11) not null auto_increment,
	customer_name varchar(255) not null,
	money decimal(10,2) not null,
	primary key(id),
	unique uni_name using btree (customer_name)
) ENGINE = 'InnoDB' AUTO_INCREMENT=10 COMMENT = '账户表';
复制代码
```

### 验证RU（未提交读）

1、开启两个会话，设置隔离级别为read uncommited

```
set session transaction isolation level read uncommitted;

select @@session.tx_isolation;
复制代码
```



![img](http://zhaojiaxing.gitee.io/image/images/16e63ff555c586bd)


2、会话1开启事务





![img](http://zhaojiaxing.gitee.io/image/images/16e640dcc330bbd4)

3、会话2开启事务并插入一条数据





![img](http://zhaojiaxing.gitee.io/image/images/16e640f1779ba3c7)

4、会话1开始查询数据库，查到了会话2事务未提交的数据





![img](http://zhaojiaxing.gitee.io/image/images/16e640ffbbd7863e)

5、会话2如果此时回滚了，会话1就查不到了





![img](http://zhaojiaxing.gitee.io/image/images/16e6411240e237b1)





![img](http://zhaojiaxing.gitee.io/image/images/16e641161a8c3928)

小结：在RU模式下，一个事务可以读取到另一个未提交事务的数据，导致了脏读。如果另一个事务回滚了，就会造成数据的不一致性。RU是事务隔离级别中最低的。



### RC（读提交）

1、将会话1和会话2的隔离级别设置成读提交模式

```
set session transaction isolation level read committed;
复制代码
```



![img](http://zhaojiaxing.gitee.io/image/images/16e6416362c05910)

2、会话1和会话2都开启事务，会话1查询当前数据



![img](http://zhaojiaxing.gitee.io/image/images/16e641f7912d97bb)





![img](http://zhaojiaxing.gitee.io/image/images/16e641faa3077bfc)

3、会话2更新数据但未提交，会话1查询当前数据还是没改



![img](http://zhaojiaxing.gitee.io/image/images/16e6421a36d2c6c4)



![img](http://zhaojiaxing.gitee.io/image/images/16e6421f4fbd1f48)



4、但是会话2此时事务提交，会话1查询当前数据变了





![img](http://zhaojiaxing.gitee.io/image/images/16e6422e79e1af12)





![img](http://zhaojiaxing.gitee.io/image/images/16e64232d73a1225)



小结：在RC模式下，我们发现，当另一个事务没有提交数据修改时，当前事务时读不到修改后的数据的，这就避免了读未提交模式的脏读。但有一个问题，在当前事务中，两次select的数据不一样，这就存在了不可重复读的问题。PS:RC隔离级别是Oracle数据库默认的隔离级别。

### RR（可重复读）

1、将会话1和会话2的隔离级别都设置成可重复读

```
set session transaction isolation level repeatable read;
复制代码
```



![img](http://zhaojiaxing.gitee.io/image/images/16e642a36274da47)

2、会话1开启事务并查询当前数据，会话2开启事务并更新数据





![img](http://zhaojiaxing.gitee.io/image/images/16e642bf567349ce)





![img](http://zhaojiaxing.gitee.io/image/images/16e642c7612f20b1)

3、此时会话1查询数据还是之前的数据

![img](http://zhaojiaxing.gitee.io/image/images/16e642ce8fe37d3a)

4、然后会话2提交事务，会话1查询数据还是之前的数据，这表示会话2的更改并没有影响当前的事务，可以重复读取。



![img](http://zhaojiaxing.gitee.io/image/images/16e642e35438d312)

5、此时会话1提交当前事务，并再次读取数据，发现其他事务改了数据





![img](http://zhaojiaxing.gitee.io/image/images/16e642f15ab7f123)

小结：在RR模式下，我们解决了不可重复读的问题，即在这种隔离级别下，一个事务中我们能够保证获取一样的数据（即使有其他事务正在改当前的数据行）。但是无法避免幻读，**幻读简单的解释就是在数据有新增的时候，也无法保证两次得到的数据不一致**但是不同数据库对不同的RR级别有不同的实现，有时候加上间隙锁来避免幻读。



### InnoDB解决了幻读

#### 结论

首先说结论：**在RR的隔离级别下**，InnoDB使用MVCC和next-key locks(间隙锁)解决幻读。MVCC解决的是普通读（快照读）的幻读，间隙锁解决的是当前读情况下的幻读。

#### 幻读是什么

(首先声明：在RR模式下，引擎是InnoDB，无法产生以下效果。)
1、事务1先执行，但未提交

```
start transaction;
update account set account=1000 where id>10;
复制代码
```

结果为：OK row xx表名成功影响多少行 2、事务2后执行，并且提交

```
start transaction;
insert into account(customer_name, money) values('李云龙',10000);
commit;
复制代码
```

3、事务1再select一下，结果集为：

```
select * from account;
复制代码
```

··· 李云龙，10000
这时，事务1蒙了，不是已经将id>10的所有人的金额都更新成1000了吗，怎么多出一个人金额是10000？这是已提交事务2对事务1产生的影响，这个影响就叫做幻读。

#### 幻读和不可重复读的区别

不可重复读：多次读取一条记录，发现该记录中某些列值被修改过。
幻读：只要是说多次读取一个范围内的记录（包括直接查询所有记录结果或者做聚合统计），发现结果不一致（一般指的是记录增多，记录的减少应该也算是幻读）。

#### 怎么解决幻读

**当前读**
所谓当前读，指的是加锁的select(S锁或者X锁)，update或者delete语句。在RR的事务隔离级别下，数据库会使用间隙锁来锁住本条记录以及索引区间。例如：
select * from account where id>10 for update;锁住的就是id=10的记录以及id>10的这个区间范围，避免范围间插入记录，以避免产生幻影行记录。
**普通读**
因为普通读是不会加锁的读，所以解决幻读的手段是MVCC。MVCC会给每行元祖加一些辅助字段，记录创建版本号和删除版本号。在每一个事务启动的时候，都有一个唯一的递增的版本号。每开启一个新事务，事务的版本号就会递增。MYSQL默认的隔离级别（可重复读Repeatable Read）下，增删改查就变成下面这样：

- select：读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
- insert：将当前事务的版本号保存至行的创建版本号。
- update：新插入一行，并以当前事务版本号作为新行的创建版本号，同时将原纪录行的删除版本号设置为当前事务版本号。
- delete：将当前事务版本号保存至行的删除版本号。 有点绕，总结下来就是每行多了两个版本号，一个创建版本号和一个删除版本号，都是保存事务的版本号。下面举个例子理解一下： 例如我插入一条记录，事务id=1，那么记录如下：

| id   | name | createversion | deleteversion |
| ---- | ---- | ------------- | ------------- |
| 1    | 马云 | 1             |               |

如果我把name更新成刘强东，事务id=2,那么记录就变成

| id   | name   | createversion | deleteversion |
| ---- | ------ | ------------- | ------------- |
| 1    | 马云   | 1             | 2             |
| 2    | 刘强东 | 2             |               |

=> 可以看出，原来的元祖的deleteversion为更新的这个事务的id，并且新增一条
如果删除的话，假设事务id=3，删除id=2的记录

| id   | name   | createversion | deleteversion |
| ---- | ------ | ------------- | ------------- |
| 1    | 马云   | 1             | 2             |
| 2    | 刘强东 | 2             | 3             |

关键点来了，如果我现在读取的话，需要同时满足两个条件：
1、读取创建版本小于或等于当前事务的版本号，这意味着数据在这个事务之前被创建
2、删除版本为空或者大于当前事务版本号的记录。这意味着删除操作在这个事务之后发生
所以当事务1插入一条记录，事物2更新这条记录并删除这条记录之后，事务1再次查询这条记录，只有id=1的记录满足这两个条件，所以结果为：（避免了幻读）

| id   | name | createversion | deleteversion |
| ---- | ---- | ------------- | ------------- |
| 1    | 马云 | 1             | 2             |

### 串行化

所有事务串行执行，是最高的隔离级别，性能最差

## 总结

这篇文章就到这了，总的来说数据库事务的四个特性ACID和四种隔离级别（RU,RC,RR,串行化）以及会产生的问题（脏读、不可重复读、幻读）是面试的高频问点，什么东西都需要积累，然后反复的温习，这样才能记忆和理解的更深刻。